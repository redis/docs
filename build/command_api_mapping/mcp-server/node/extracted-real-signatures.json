{
  "GET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def get(self, fmt: str, offset: BitfieldOffsetT)",
          "summary": "Return the value at key ``name``, or None if the key doesn't exist For more information, see https://redis.io/commands/get",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "def get(self, name: KeyT)",
          "summary": "Return the value at key ``name``, or None if the key doesn't exist For more information, see https://redis.io/commands/get",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String get(final String key)",
          "summary": "Get the value of the specified key. If the key does not exist the special value 'nil' is",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V get(K key)",
          "summary": "Get the value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the value of {@code key}, or {@code null} when {@code key} does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> get(K key)",
          "summary": "Get the value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the value of {@code key}, or {@code null} when {@code key} does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> get(K key)",
          "summary": "Get the value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the value of {@code key}, or {@code null} when {@code key} does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) Get(ctx context.Context, key string)",
          "summary": "Get Redis `GET key` command. It returns redis.Nil error when key does not exist.",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "GET(parser: CommandParser, key: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "get()",
          "summary": "Get the value of a key",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn get(key: K)",
          "summary": "Set the GET option for the SET command",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        },
        {
          "signature": "fn get(mut self, get: bool)",
          "summary": "Set the GET option for the SET command",
          "params": [
            {
              "name": "mut self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "Self",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn get(key: K)",
          "summary": "Set the GET option for the SET command",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        },
        {
          "signature": "fn get(mut self, get: bool)",
          "summary": "Set the GET option for the SET command",
          "params": [
            {
              "name": "mut self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "Self",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys of the strings."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(key, flags)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys of the strings."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys of the strings."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(key, flags)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value <see cref=\"RedisValue.Null\"/> is returned.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys of the strings."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "get(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "SET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def set(self, fmt: str, offset: BitfieldOffsetT, value: int)",
          "summary": "Set the value of a given bitfield. :param fmt: format-string for the bitfield being read, e.g. 'u8' for an unsigned 8-bit integer. :param offset: offset (in number of bits). If prefixed with a '#', this is an offset multiplier, e.g. given the arguments fmt='u8', offset='#2', the offset will be 16. :param int value: value to set at the given position. :returns: a :py:class:`BitFieldOperation` instance.",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            },
            {
              "name": "value",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "def set(self,, name: KeyT,, value: EncodableT,, ex: Optional[ExpiryT] = None,, px: Optional[ExpiryT] = None,, nx: bool = False,, xx: bool = False,, keepttl: bool = False,, get: bool = False,, exat: Optional[AbsExpiryT] = None,, pxat: Optional[AbsExpiryT] = None,, ifeq: Optional[Union[bytes, str]] = None,, ifne: Optional[Union[bytes, str]] = None,, ifdeq: Optional[str] = None,  # hex digest of current value, ifdne: Optional[str] = None,  # hex digest of current value)",
          "summary": "Set the value of a given bitfield. :param fmt: format-string for the bitfield being read, e.g. 'u8' for an unsigned 8-bit integer. :param offset: offset (in number of bits). If prefixed with a '#', this is an offset multiplier, e.g. given the arguments fmt='u8', offset='#2', the offset will be 16. :param int value: value to set at the given position. :returns: a :py:class:`BitFieldOperation` instance.",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            },
            {
              "name": "ex",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "px",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "keepttl",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "exat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "pxat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "ifeq",
              "type": "Optional[Union[bytes",
              "description": ""
            },
            {
              "name": "str]] = None",
              "type": "Any",
              "description": ""
            },
            {
              "name": "ifne",
              "type": "Optional[Union[bytes",
              "description": ""
            },
            {
              "name": "str]] = None",
              "type": "Any",
              "description": ""
            },
            {
              "name": "ifdeq",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "# hex digest of current value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "ifdne",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "# hex digest of current value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String set(final byte[] key, final byte[] value)",
          "summary": "Set the string value as value of the key. The string can't be longer than 1073741824 bytes (1",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final byte[] value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply {@code OK} if {@code SET} was executed correctly, or {@code null} if the {@code SET} operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final byte[] key, final byte[] value, final SetParams params)",
          "summary": "Set the string value as value of the key. The string can't be longer than 1073741824 bytes (1",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final byte[] value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final SetParams params",
              "type": "Any",
              "description": "key if it already exists. EX|PX, expire time units: EX = seconds; PX = milliseconds"
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply {@code OK} if {@code SET} was executed correctly, or {@code null} if the {@code SET} operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final String key, final String value)",
          "summary": "Set the string value as value of the key. The string can't be longer than 1073741824 bytes (1",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final String value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply {@code OK} if {@code SET} was executed correctly, or {@code null} if the {@code SET} operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final String key, final String value, final SetParams params)",
          "summary": "Set the string value as value of the key. The string can't be longer than 1073741824 bytes (1",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final String value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final SetParams params",
              "type": "Any",
              "description": "key if it already exists. EX|PX, expire time units: EX = seconds; PX = milliseconds"
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply {@code OK} if {@code SET} was executed correctly, or {@code null} if the {@code SET} operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String set(K key, V value)",
          "summary": "Set the string value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V value",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        },
        {
          "signature": "String set(K key, V value, SetArgs setArgs)",
          "summary": "Set the string value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V value",
              "type": "Any",
              "description": "the value."
            },
            {
              "name": "SetArgs setArgs",
              "type": "Any",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> set(K key, V value)",
          "summary": "Set the string value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V value",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        },
        {
          "signature": "RedisFuture<String> set(K key, V value, SetArgs setArgs)",
          "summary": "Set the string value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V value",
              "type": "Any",
              "description": "the value."
            },
            {
              "name": "SetArgs setArgs",
              "type": "Any",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> set(K key, V value)",
          "summary": "Set the string value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V value",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        },
        {
          "signature": "Mono<String> set(K key, V value, SetArgs setArgs)",
          "summary": "Set the string value of a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V value",
              "type": "Any",
              "description": "the value."
            },
            {
              "name": "SetArgs setArgs",
              "type": "Any",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) Set(ctx context.Context, key string, value interface{}, expiration time.Duration)",
          "summary": "Set Redis `SET key value [expiration]` command.",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "value interface{}",
              "type": "Any",
              "description": ""
            },
            {
              "name": "expiration time.Duration",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StatusCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SET(parser: CommandParser, key: RedisArgument, value: RedisArgument | number, options?: SetOptions)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument | number",
              "description": ""
            },
            {
              "name": "options?",
              "type": "SetOptions",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "set()",
          "summary": "Set the string value of a key",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "summary": "Set the string value of a key",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "summary": "Set the string value of a key",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "summary": "Set the string value of a key",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "summary": "Set the string value of a key",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn set(key: K, value: V)",
          "summary": "Set the string value of a key. [Redis Docs](https://redis.io/commands/SET)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn set(key: K, value: V)",
          "summary": "Set the string value of a key. [Redis Docs](https://redis.io/commands/SET)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The expiry to set."
            },
            {
              "name": "When when",
              "type": "Any",
              "description": "Which condition to set the value under (defaults to always)."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when, CommandFlags flags)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The expiry to set."
            },
            {
              "name": "When when",
              "type": "Any",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, bool keepTtl, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The expiry to set."
            },
            {
              "name": "bool keepTtl",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, Expiration expiry = default, ValueCondition when = default, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "Expiration expiry = default",
              "type": "Any",
              "description": ""
            },
            {
              "name": "ValueCondition when = default",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(KeyValuePair<RedisKey, RedisValue>[] values, When when, CommandFlags flags)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "KeyValuePair<RedisKey",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue>[] values",
              "type": "Any",
              "description": "The keys and values to set."
            },
            {
              "name": "When when",
              "type": "Any",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The expiry to set."
            },
            {
              "name": "When when",
              "type": "Any",
              "description": "Which condition to set the value under (defaults to always)."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when, CommandFlags flags)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The expiry to set."
            },
            {
              "name": "When when",
              "type": "Any",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, bool keepTtl, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The expiry to set."
            },
            {
              "name": "bool keepTtl",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, Expiration expiry = default, ValueCondition when = default, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "Expiration expiry = default",
              "type": "Any",
              "description": ""
            },
            {
              "name": "ValueCondition when = default",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(KeyValuePair<RedisKey, RedisValue>[] values, When when, CommandFlags flags)",
          "summary": "Sets the given keys to their respective values, optionally including expiration. If <see cref=\"When.NotExists\"/> is specified, this will not perform any operation at all even if just a single key already exists.",
          "params": [
            {
              "name": "KeyValuePair<RedisKey",
              "type": "Any",
              "description": ""
            },
            {
              "name": "RedisValue>[] values",
              "type": "Any",
              "description": "The keys and values to set."
            },
            {
              "name": "When when",
              "type": "Any",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        }
      ],
      "php": [
        {
          "signature": "set(string $key, $value, $expireResolution = null, $expireTTL = null, $flag = null, $flagValue = null)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$expireResolution = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$expireTTL = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$flag = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$flagValue = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Status|null",
            "description": ""
          }
        }
      ]
    }
  },
  "MGET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def mget(self, keys: KeysT, *args: EncodableT)",
          "summary": "Returns a list of values ordered identically to ``keys`` ** Important ** When this method is used with Cluster clients, all keys must be in the same hash slot, otherwise a RedisClusterException will be raised. For more information, see https://redis.io/commands/mget",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "keys",
              "type": "KeysT",
              "description": ""
            },
            {
              "name": "*args",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> mget(final String... keys)",
          "summary": "Get the values of all the specified keys. If one or more keys don't exist or is not of type",
          "params": [
            {
              "name": "final String... keys",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Multi bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<KeyValue<K, V>> mget(K... keys)",
          "summary": "Stream over the values of all the given keys.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "List<KeyValue<K, V>>",
            "description": "Long array-reply list of values at the specified keys."
          }
        },
        {
          "signature": "Long mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "summary": "Stream over the values of all the given keys.",
          "params": [
            {
              "name": "KeyValueStreamingChannel<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long array-reply list of values at the specified keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<KeyValue<K, V>>> mget(K... keys)",
          "summary": "Stream over the values of all the given keys.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<KeyValue<K, V>>>",
            "description": "Long array-reply list of values at the specified keys."
          }
        },
        {
          "signature": "RedisFuture<Long> mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "summary": "Stream over the values of all the given keys.",
          "params": [
            {
              "name": "KeyValueStreamingChannel<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long array-reply list of values at the specified keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> mget(K... keys)",
          "summary": "Stream over the values of all the given keys.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long array-reply list of values at the specified keys. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #mget}."
          }
        },
        {
          "signature": "Mono<Long> mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "summary": "Stream over the values of all the given keys.",
          "params": [
            {
              "name": "KeyValueStreamingChannel<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long array-reply list of values at the specified keys. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #mget}."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) MGet(ctx context.Context, keys ...string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "keys ...string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*SliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "MGET(parser: CommandParser, keys: Array<RedisArgument>)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "keys",
              "type": "Array<RedisArgument>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "mget()",
          "summary": "Get the values of all the given keys",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mget()",
          "summary": "Get the values of all the given keys",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mget(...args: [...keys: RedisKey[]])",
          "summary": "Get the values of all the given keys",
          "params": [
            {
              "name": "...args",
              "type": "[...keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<(string | null)[], Context>",
            "description": ""
          }
        },
        {
          "signature": "mget(...args: [keys: RedisKey[]])",
          "summary": "Get the values of all the given keys",
          "params": [
            {
              "name": "...args",
              "type": "[keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<(string | null)[], Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn mget(key: K)",
          "summary": "Get values of keys [Redis Docs](https://redis.io/commands/MGET)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<Option<String>>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn mget(key: K)",
          "summary": "Get values of keys [Redis Docs](https://redis.io/commands/MGET)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<Option<String>>)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "mget(string[]|string $keyOrKeys, string ...$keys = null)",
          "summary": "",
          "params": [
            {
              "name": "string[]|string $keyOrKeys",
              "type": "Any",
              "description": ""
            },
            {
              "name": "string ...$keys = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "MSET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def mset(self, mapping: Mapping[AnyKeyT, EncodableT])",
          "summary": "Sets key/values based on a mapping. Mapping is a dictionary of key/value pairs. Both keys and values should be strings or types that can be cast to a string via str(). ** Important ** When this method is used with Cluster clients, all keys must be in the same hash slot, otherwise a RedisClusterException will be raised. For more information, see https://redis.io/commands/mset",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "mapping",
              "type": "Mapping[AnyKeyT",
              "description": ""
            },
            {
              "name": "EncodableT]",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String mset(final byte[]... keysvalues)",
          "summary": "Set the respective keys to the respective values. MSET will replace old values with new",
          "params": [
            {
              "name": "final byte[]... keysvalues",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK"
          }
        },
        {
          "signature": "String mset(final String... keysvalues)",
          "summary": "Set the respective keys to the respective values. MSET will replace old values with new",
          "params": [
            {
              "name": "final String... keysvalues",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String mset(Map<K, V> map)",
          "summary": "Set multiple keys to multiple values.",
          "params": [
            {
              "name": "Map<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> map",
              "type": "Any",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply always {@code OK} since {@code MSET} can't fail."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> mset(Map<K, V> map)",
          "summary": "Set multiple keys to multiple values.",
          "params": [
            {
              "name": "Map<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> map",
              "type": "Any",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply always {@code OK} since {@code MSET} can't fail."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> mset(Map<K, V> map)",
          "summary": "Set multiple keys to multiple values.",
          "params": [
            {
              "name": "Map<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> map",
              "type": "Any",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply always {@code OK} since {@code MSET} can't fail."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) MSet(ctx context.Context, values ...interface{})",
          "summary": "MSet is like Set but accepts multiple values:",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "values ...interface{}",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StatusCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "MSET(parser: CommandParser, toSet: MSetArguments)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "toSet",
              "type": "MSetArguments",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "mset(object: object, callback?: Callback<\"OK\">)",
          "summary": "Set multiple keys to multiple values",
          "params": [
            {
              "name": "object",
              "type": "object",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<\"OK\">",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<\"OK\", Context>",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "summary": "Set multiple keys to multiple values",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "summary": "Set multiple keys to multiple values",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "summary": "Set multiple keys to multiple values",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn mset(items: &'a [(K, V)])",
          "summary": "Sets multiple keys to their values. [Redis Docs](https://redis.io/commands/MSET)",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K",
              "description": ""
            },
            {
              "name": "V)]",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn mset(items: &'a [(K, V)])",
          "summary": "Sets multiple keys to their values. [Redis Docs](https://redis.io/commands/MSET)",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K",
              "description": ""
            },
            {
              "name": "V)]",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "mset(array $dictionary)",
          "summary": "",
          "params": [
            {
              "name": "array $dictionary",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "mixed",
            "description": ""
          }
        }
      ]
    }
  },
  "INCR": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def incrby(self,, fmt: str,, offset: BitfieldOffsetT,, increment: int,, overflow: Optional[str] = None,)",
          "summary": "Increments the value of ``key`` by ``amount``.  If no key exists, the value will be initialized as ``amount`` For more information, see https://redis.io/commands/incrby",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            },
            {
              "name": "increment",
              "type": "int",
              "description": ""
            },
            {
              "name": "overflow",
              "type": "Optional[str] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "def incrby(self, name: KeyT, amount: int = 1)",
          "summary": "Increments the value of ``key`` by ``amount``.  If no key exists, the value will be initialized as ``amount`` For more information, see https://redis.io/commands/incrby",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long incrBy(final byte[] key, final long increment)",
          "summary": "INCRBY work just like {@link Jedis#incr(String) INCR} but instead to increment by 1 the",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long increment",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incr(final byte[] key)",
          "summary": "Increment the number stored at key by one. If the key does not exist or contains a value of a",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incrBy(final String key, final long increment)",
          "summary": "INCRBY work just like {@link Jedis#incr(String) INCR} but instead to increment by 1 the",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long increment",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incr(final String key)",
          "summary": "Increment the number stored at key by one. If the key does not exist or contains a value of a",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long incr(K key)",
          "summary": "Increment the integer value of a key by one.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        },
        {
          "signature": "Long incrby(K key, long amount)",
          "summary": "Increment the integer value of a key by the given amount.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long amount",
              "type": "Any",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> incr(K key)",
          "summary": "Increment the integer value of a key by one.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        },
        {
          "signature": "RedisFuture<Long> incrby(K key, long amount)",
          "summary": "Increment the integer value of a key by the given amount.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long amount",
              "type": "Any",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> incr(K key)",
          "summary": "Increment the integer value of a key by one.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        },
        {
          "signature": "Mono<Long> incrby(K key, long amount)",
          "summary": "Increment the integer value of a key by the given amount.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long amount",
              "type": "Any",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) Incr(ctx context.Context, key string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        },
        {
          "signature": "func (c cmdable) IncrBy(ctx context.Context, key string, value int64)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "value int64",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "INCR(parser: CommandParser, key: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "incr(key: RedisKey, callback?: Callback<number>)",
          "summary": "Increment the integer value of a key by one",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "incrby()",
          "summary": "Increment the integer value of a key by the given amount",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn incr(key: K, delta: V)",
          "summary": "Increment the numeric value of a key by the given amount.  This issues a `INCRBY` or `INCRBYFLOAT` depending on the type. If the key does not exist, it is set to 0 before performing the operation.",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn incr(key: K, delta: V)",
          "summary": "Increment the numeric value of a key by the given amount.  This issues a `INCRBY` or `INCRBYFLOAT` depending on the type. If the key does not exist, it is set to 0 before performing the operation.",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "long value = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "double value",
              "type": "Any",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "long value = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "long value = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "double value",
              "type": "Any",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "summary": "Increments the string representing a floating point number stored at key by the specified increment. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "long value = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "php": [
        {
          "signature": "incr(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        },
        {
          "signature": "incrby(string $key, int $increment)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "int $increment",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "DECR": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def decrby(self, name: KeyT, amount: int = 1)",
          "summary": "Decrements the value of ``key`` by ``amount``.  If no key exists, the value will be initialized as 0 - ``amount`` For more information, see https://redis.io/commands/decrby",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long decrBy(final byte[] key, final long decrement)",
          "summary": "IDECRBY work just like {@link Jedis#decr(String) INCR} but instead to decrement by 1 the",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long decrement",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decr(final byte[] key)",
          "summary": "Decrement the number stored at key by one. If the key does not exist or contains a value of a",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decrBy(final String key, final long decrement)",
          "summary": "IDECRBY work just like {@link Jedis#decr(String) INCR} but instead to decrement by 1 the",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long decrement",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decr(final String key)",
          "summary": "Decrement the number stored at key by one. If the key does not exist or contains a value of a",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long decr(K key)",
          "summary": "Decrement the integer value of a key by one.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        },
        {
          "signature": "Long decrby(K key, long amount)",
          "summary": "Decrement the integer value of a key by the given number.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long amount",
              "type": "Any",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> decr(K key)",
          "summary": "Decrement the integer value of a key by one.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        },
        {
          "signature": "RedisFuture<Long> decrby(K key, long amount)",
          "summary": "Decrement the integer value of a key by the given number.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long amount",
              "type": "Any",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> decr(K key)",
          "summary": "Decrement the integer value of a key by one.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        },
        {
          "signature": "Mono<Long> decrby(K key, long amount)",
          "summary": "Decrement the integer value of a key by the given number.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long amount",
              "type": "Any",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) Decr(ctx context.Context, key string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        },
        {
          "signature": "func (c cmdable) DecrBy(ctx context.Context, key string, decrement int64)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "decrement int64",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "DECR(parser: CommandParser, key: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "decr(key: RedisKey, callback?: Callback<number>)",
          "summary": "Decrement the integer value of a key by one",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "decrby()",
          "summary": "Decrement the integer value of a key by the given number",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn decr(key: K, delta: V)",
          "summary": "Decrement the numeric value of a key by the given amount. If the key does not exist, it is set to 0 before performing the operation. [Redis Docs](https://redis.io/commands/DECRBY)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn decr(key: K, delta: V)",
          "summary": "Decrement the numeric value of a key by the given amount. If the key does not exist, it is set to 0 before performing the operation. [Redis Docs](https://redis.io/commands/DECRBY)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "summary": "Decrements the string representing a floating point number stored at key by the specified decrement. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "long value = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "summary": "Decrements the string representing a floating point number stored at key by the specified decrement. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "double value",
              "type": "Any",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "summary": "Decrements the string representing a floating point number stored at key by the specified decrement. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "long value = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "summary": "Decrements the string representing a floating point number stored at key by the specified decrement. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "double value",
              "type": "Any",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "summary": "Decrements the string representing a floating point number stored at key by the specified decrement. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "long value = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "summary": "Decrements the string representing a floating point number stored at key by the specified decrement. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "double value",
              "type": "Any",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "summary": "Decrements the string representing a floating point number stored at key by the specified decrement. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "long value = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "summary": "Decrements the string representing a floating point number stored at key by the specified decrement. If the key does not exist, it is set to 0 before performing the operation. The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "double value",
              "type": "Any",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        }
      ],
      "php": [
        {
          "signature": "decr(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        },
        {
          "signature": "decrby(string $key, int $decrement)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "int $decrement",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "DEL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def delete(self, *names: KeyT)",
          "summary": "Delete one or more keys specified by ``names``",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "*names",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long del(final byte[]... keys)",
          "summary": "Remove the specified keys. If a given key does not exist no operation is performed for this",
          "params": [
            {
              "name": "final byte[]... keys",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "An integer greater than 0 if one or more keys were removed, 0 if none of the specified keys existed"
          }
        },
        {
          "signature": "long del(final byte[] key)",
          "summary": "Remove the specified keys. If a given key does not exist no operation is performed for this",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "An integer greater than 0 if one or more keys were removed, 0 if none of the specified keys existed"
          }
        },
        {
          "signature": "long del(final String... keys)",
          "summary": "Remove the specified keys. If a given key does not exist no operation is performed for this",
          "params": [
            {
              "name": "final String... keys",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "An integer greater than 0 if one or more keys were removed, 0 if none of the specified keys existed"
          }
        },
        {
          "signature": "long del(final String key)",
          "summary": "Remove the specified keys. If a given key does not exist no operation is performed for this",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "An integer greater than 0 if one or more keys were removed, 0 if none of the specified keys existed"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long del(K... keys)",
          "summary": "Delete one or more keys.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply The number of keys that were removed."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> del(K... keys)",
          "summary": "Delete one or more keys.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply The number of keys that were removed."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> del(K... keys)",
          "summary": "Delete one or more keys.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply The number of keys that were removed."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) Del(ctx context.Context, keys ...string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "keys ...string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "DEL(parser: CommandParser, keys: RedisVariadicArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "keys",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "del()",
          "summary": "Delete a key",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "del()",
          "summary": "Delete a key",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "del(...args: [...keys: RedisKey[]])",
          "summary": "Delete a key",
          "params": [
            {
              "name": "...args",
              "type": "[...keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "del(...args: [keys: RedisKey[]])",
          "summary": "Delete a key",
          "params": [
            {
              "name": "...args",
              "type": "[keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn del(key: K)",
          "summary": "Delete one or more keys. Returns the number of keys deleted. [Redis Docs](https://redis.io/commands/DEL)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn del(key: K)",
          "summary": "Delete one or more keys. Returns the number of keys deleted. [Redis Docs](https://redis.io/commands/DEL)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to delete."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to delete."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(key, flags)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The number of keys that were removed."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to delete."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to delete."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(key, flags)",
          "summary": "Removes the specified keys. A key is ignored if it does not exist. If UNLINK is available (Redis 4.0+), it will be used.",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The number of keys that were removed."
          }
        }
      ],
      "php": [
        {
          "signature": "del(string[]|string $keyOrKeys, string ...$keys = null)",
          "summary": "",
          "params": [
            {
              "name": "string[]|string $keyOrKeys",
              "type": "Any",
              "description": ""
            },
            {
              "name": "string ...$keys = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "EXISTS": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def exists(self, *names: KeyT)",
          "summary": "Returns the number of ``names`` that exist For more information, see https://redis.io/commands/exists",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "*names",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long exists(final byte[]... keys)",
          "summary": "Test if the specified key exists. The command returns true if the key exists, otherwise false is",
          "params": [
            {
              "name": "final byte[]... keys",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "{@code true} if the key exists, otherwise {@code false}"
          }
        },
        {
          "signature": "boolean exists(final byte[] key)",
          "summary": "Test if the specified key exists. The command returns true if the key exists, otherwise false is",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "boolean",
            "description": "{@code true} if the key exists, otherwise {@code false}"
          }
        },
        {
          "signature": "long exists(final String... keys)",
          "summary": "Test if the specified key exists. The command returns true if the key exists, otherwise false is",
          "params": [
            {
              "name": "final String... keys",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "{@code true} if the key exists, otherwise {@code false}"
          }
        },
        {
          "signature": "boolean exists(final String key)",
          "summary": "Test if the specified key exists. The command returns true if the key exists, otherwise false is",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "boolean",
            "description": "{@code true} if the key exists, otherwise {@code false}"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long exists(K... keys)",
          "summary": "Determine how many keys exist.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply specifically: Number of existing keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> exists(K... keys)",
          "summary": "Determine how many keys exist.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply specifically: Number of existing keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> exists(K... keys)",
          "summary": "Determine how many keys exist.",
          "params": [
            {
              "name": "K... keys",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply specifically: Number of existing keys."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) Exists(ctx context.Context, keys ...string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "keys ...string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "EXISTS(parser: CommandParser, keys: RedisVariadicArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "keys",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "exists()",
          "summary": "Determine if a key exists",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "exists()",
          "summary": "Determine if a key exists",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "exists(...args: [...keys: RedisKey[]])",
          "summary": "Determine if a key exists",
          "params": [
            {
              "name": "...args",
              "type": "[...keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "exists(...args: [keys: RedisKey[]])",
          "summary": "Determine if a key exists",
          "params": [
            {
              "name": "...args",
              "type": "[keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn exists(key: K)",
          "summary": "Determine if a key exists. [Redis Docs](https://redis.io/commands/EXISTS)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn exists(key: K)",
          "summary": "Determine if a key exists. [Redis Docs](https://redis.io/commands/EXISTS)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Indicates how many of the supplied keys exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Indicates how many of the supplied keys exists.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to check."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Indicates how many of the supplied keys exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Indicates how many of the supplied keys exists.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to check."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that existed."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Indicates how many of the supplied keys exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Indicates how many of the supplied keys exists.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to check."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Indicates how many of the supplied keys exists.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "summary": "Indicates how many of the supplied keys exists.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to check."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that existed."
          }
        }
      ],
      "php": [
        {
          "signature": "exists(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "EXPIRE": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def expire(self,, name: KeyT,, time: ExpiryT,, nx: bool = False,, xx: bool = False,, gt: bool = False,, lt: bool = False,)",
          "summary": "",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "time",
              "type": "ExpiryT",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "gt",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "lt",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long expire(final byte[] key, final long seconds)",
          "summary": "Similar to {@link Jedis#expire(String, long) EXPIRE} but with optional expiry setting.",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long seconds",
              "type": "Any",
              "description": "time to expire"
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the timeout was set, 0 otherwise. Since the key already has an associated timeout (this may happen only in Redis versions &lt; 2.1.3, Redis &gt;= 2.1.3 will happily update the timeout), or the key does not exist."
          }
        },
        {
          "signature": "long expire(final byte[] key, final long seconds, final ExpiryOption expiryOption)",
          "summary": "Similar to {@link Jedis#expire(String, long) EXPIRE} but with optional expiry setting.",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long seconds",
              "type": "Any",
              "description": "time to expire"
            },
            {
              "name": "final ExpiryOption expiryOption",
              "type": "Any",
              "description": "can be NX, XX, GT or LT"
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the timeout was set, 0 otherwise. Since the key already has an associated timeout (this may happen only in Redis versions &lt; 2.1.3, Redis &gt;= 2.1.3 will happily update the timeout), or the key does not exist."
          }
        },
        {
          "signature": "long expire(final String key, final long seconds)",
          "summary": "Similar to {@link Jedis#expire(String, long) EXPIRE} but with optional expiry setting.",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long seconds",
              "type": "Any",
              "description": "time to expire"
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the timeout was set, 0 otherwise. Since the key already has an associated timeout (this may happen only in Redis versions &lt; 2.1.3, Redis &gt;= 2.1.3 will happily update the timeout), or the key does not exist."
          }
        },
        {
          "signature": "long expire(final String key, final long seconds, final ExpiryOption expiryOption)",
          "summary": "Similar to {@link Jedis#expire(String, long) EXPIRE} but with optional expiry setting.",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long seconds",
              "type": "Any",
              "description": "time to expire"
            },
            {
              "name": "final ExpiryOption expiryOption",
              "type": "Any",
              "description": "can be NX, XX, GT or LT"
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the timeout was set, 0 otherwise. Since the key already has an associated timeout (this may happen only in Redis versions &lt; 2.1.3, Redis &gt;= 2.1.3 will happily update the timeout), or the key does not exist."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean expire(K key, long seconds)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long seconds",
              "type": "Any",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Boolean expire(K key, long seconds, ExpireArgs expireArgs)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long seconds",
              "type": "Any",
              "description": "the seconds."
            },
            {
              "name": "ExpireArgs expireArgs",
              "type": "Any",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Boolean expire(K key, Duration seconds)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "Duration seconds",
              "type": "Any",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Boolean expire(K key, Duration seconds, ExpireArgs expireArgs)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "Duration seconds",
              "type": "Any",
              "description": "the seconds."
            },
            {
              "name": "ExpireArgs expireArgs",
              "type": "Any",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> expire(K key, long seconds)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long seconds",
              "type": "Any",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "RedisFuture<Boolean> expire(K key, long seconds, ExpireArgs expireArgs)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long seconds",
              "type": "Any",
              "description": "the seconds."
            },
            {
              "name": "ExpireArgs expireArgs",
              "type": "Any",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "RedisFuture<Boolean> expire(K key, Duration seconds)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "Duration seconds",
              "type": "Any",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "RedisFuture<Boolean> expire(K key, Duration seconds, ExpireArgs expireArgs)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "Duration seconds",
              "type": "Any",
              "description": "the seconds."
            },
            {
              "name": "ExpireArgs expireArgs",
              "type": "Any",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> expire(K key, long seconds)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long seconds",
              "type": "Any",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Mono<Boolean> expire(K key, long seconds, ExpireArgs expireArgs)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long seconds",
              "type": "Any",
              "description": "the seconds."
            },
            {
              "name": "ExpireArgs expireArgs",
              "type": "Any",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Mono<Boolean> expire(K key, Duration seconds)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "Duration seconds",
              "type": "Any",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Mono<Boolean> expire(K key, Duration seconds, ExpireArgs expireArgs)",
          "summary": "Set a key's time to live in seconds.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "Duration seconds",
              "type": "Any",
              "description": "the seconds."
            },
            {
              "name": "ExpireArgs expireArgs",
              "type": "Any",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) Expire(ctx context.Context, key string, expiration time.Duration)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "expiration time.Duration",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*BoolCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "EXPIRE()",
          "summary": "",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "expire()",
          "summary": "Set a key's time to live in seconds",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "expire()",
          "summary": "Set a key's time to live in seconds",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "expire()",
          "summary": "Set a key's time to live in seconds",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "expire()",
          "summary": "Set a key's time to live in seconds",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "expire()",
          "summary": "Set a key's time to live in seconds",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn expire(key: K, seconds: i64)",
          "summary": "Set a key's time to live in seconds. Returns whether expiration was set. [Redis Docs](https://redis.io/commands/EXPIRE)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "i64",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn expire(key: K, seconds: i64)",
          "summary": "Set a key's time to live in seconds. Returns whether expiration was set. [Redis Docs](https://redis.io/commands/EXPIRE)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "i64",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, CommandFlags flags)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "ExpireWhen when = ExpireWhen.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, DateTime? expiry, CommandFlags flags)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "DateTime? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, DateTime? expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "DateTime? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "ExpireWhen when = ExpireWhen.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, CommandFlags flags = CommandFlags.None)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, CommandFlags flags)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "ExpireWhen when = ExpireWhen.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, DateTime? expiry, CommandFlags flags)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "DateTime? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, DateTime? expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "DateTime? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "ExpireWhen when = ExpireWhen.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, CommandFlags flags = CommandFlags.None)",
          "summary": ". After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to set the expiration for."
            },
            {
              "name": "TimeSpan? expiry",
              "type": "Any",
              "description": "The timeout to set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        }
      ],
      "php": [
        {
          "signature": "expire(string $key, int $seconds, string $expireOption = '')",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "int $seconds",
              "type": "Any",
              "description": ""
            },
            {
              "name": "string $expireOption = ''",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "TTL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def ttl(self, name: KeyT)",
          "summary": "Returns the number of seconds until the key ``name`` will expire For more information, see https://redis.io/commands/ttl",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long ttl(final byte[] key)",
          "summary": "The TTL command returns the remaining time to live in seconds of a key that has an",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "TTL in seconds, or a negative value in order to signal an error"
          }
        },
        {
          "signature": "long ttl(final String key)",
          "summary": "The TTL command returns the remaining time to live in seconds of a key that has an",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "TTL in seconds, or a negative value in order to signal an error"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long ttl(K key)",
          "summary": "Get the time to live for a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply TTL in seconds, or a negative value in order to signal an error. The command returns {@code -1} if the key exists but has no associated expiration time. The command returns {@code -2} if the key does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> ttl(K key)",
          "summary": "Get the time to live for a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply TTL in seconds, or a negative value in order to signal an error. The command returns {@code -1} if the key exists but has no associated expiration time. The command returns {@code -2} if the key does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> ttl(K key)",
          "summary": "Get the time to live for a key.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply TTL in seconds, or a negative value in order to signal an error. The command returns {@code -1} if the key exists but has no associated expiration time. The command returns {@code -2} if the key does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) TTL(ctx context.Context, key string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*DurationCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "TTL(parser: CommandParser, key: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "ttl(key: RedisKey, callback?: Callback<number>)",
          "summary": "Get the time to live for a key in seconds",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn ttl(key: K)",
          "summary": "Get the time to live for a key in seconds. Returns `ExistsButNotRelevant` if key exists but has no expiration time. [Redis Docs](https://redis.io/commands/TTL)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(IntegerReplyOrNoOp)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn ttl(key: K)",
          "summary": "Get the time to live for a key in seconds. Returns `ExistsButNotRelevant` if key exists but has no expiration time. [Redis Docs](https://redis.io/commands/TTL)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(IntegerReplyOrNoOp)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "KeyTimeToLive(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to check."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "TimeSpan?",
            "description": "TTL, or <see langword=\"null\"/> when key does not exist or does not have a timeout."
          }
        },
        {
          "signature": "KeyTimeToLive(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to check."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "TimeSpan?",
            "description": "TTL, or <see langword=\"null\"/> when key does not exist or does not have a timeout."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "KeyTimeToLive(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to check."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "TimeSpan?",
            "description": "TTL, or <see langword=\"null\"/> when key does not exist or does not have a timeout."
          }
        },
        {
          "signature": "KeyTimeToLive(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key to check."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "TimeSpan?",
            "description": "TTL, or <see langword=\"null\"/> when key does not exist or does not have a timeout."
          }
        }
      ],
      "php": [
        {
          "signature": "ttl(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "LPUSH": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def lpush(self, name: KeyT, *values: FieldT)",
          "summary": "Push ``values`` onto the head of the list ``name`` For more information, see https://redis.io/commands/lpush",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "*values",
              "type": "FieldT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long lpush(final byte[] key, final byte[]... strings)",
          "summary": "Add the string value to the head (LPUSH) or tail (RPUSH) of the list stored at key. If the key",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final byte[]... strings",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements inside the list after the push operation"
          }
        },
        {
          "signature": "long lpush(final String key, final String... strings)",
          "summary": "Add the string value to the head (LPUSH) or tail (RPUSH) of the list stored at key. If the key",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final String... strings",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements inside the list after the push operation"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long lpush(K key, V... values)",
          "summary": "Prepend one or multiple values to a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... values",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the length of the list after the push operations."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> lpush(K key, V... values)",
          "summary": "Prepend one or multiple values to a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... values",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the length of the list after the push operations."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> lpush(K key, V... values)",
          "summary": "Prepend one or multiple values to a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... values",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the length of the list after the push operations."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) LPush(ctx context.Context, key string, values ...interface{})",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "values ...interface{}",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "LPUSH(parser: CommandParser, key: RedisArgument, elements: RedisVariadicArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "elements",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "lpush()",
          "summary": "Prepend one or multiple elements to a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "lpush()",
          "summary": "Prepend one or multiple elements to a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn lpush(key: K, value: V)",
          "summary": "Insert all the specified values at the head of the list stored at key. [Redis Docs](https://redis.io/commands/LPUSH)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn lpush(key: K, value: V)",
          "summary": "Insert all the specified values at the head of the list stored at key. [Redis Docs](https://redis.io/commands/LPUSH)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command <c>LPUSH mylist a b c</c> will result into a list containing c as first element, b as second element and a as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        }
      ],
      "php": [
        {
          "signature": "lpush(string $key, array $values)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "array $values",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "RPUSH": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def rpush(self, name: KeyT, *values: FieldT)",
          "summary": "Push ``values`` onto the tail of the list ``name`` For more information, see https://redis.io/commands/rpush",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "*values",
              "type": "FieldT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long rpush(final byte[] key, final byte[]... strings)",
          "summary": "Add the string value to the head (LPUSH) or tail (RPUSH) of the list stored at key. If the key",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final byte[]... strings",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements inside the list after the push operation"
          }
        },
        {
          "signature": "long rpush(final String key, final String... strings)",
          "summary": "Add the string value to the head (LPUSH) or tail (RPUSH) of the list stored at key. If the key",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final String... strings",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements inside the list after the push operation"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long rpush(K key, V... values)",
          "summary": "Append one or multiple values to a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... values",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the length of the list after the push operation."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> rpush(K key, V... values)",
          "summary": "Append one or multiple values to a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... values",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the length of the list after the push operation."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> rpush(K key, V... values)",
          "summary": "Append one or multiple values to a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... values",
              "type": "Any",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the length of the list after the push operation."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) RPush(ctx context.Context, key string, values ...interface{})",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "values ...interface{}",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "RPUSH(parser: CommandParser, key: RedisArgument, element: RedisVariadicArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "element",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "rpush()",
          "summary": "Append one or multiple elements to a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "rpush()",
          "summary": "Append one or multiple elements to a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn rpush(key: K, value: V)",
          "summary": "Insert all the specified values at the tail of the list stored at key. [Redis Docs](https://redis.io/commands/RPUSH)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn rpush(key: K, value: V)",
          "summary": "Insert all the specified values at the tail of the list stored at key. [Redis Docs](https://redis.io/commands/RPUSH)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListRightPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListRightPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "CommandFlags flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command <c>RPUSH mylist a b c</c> will result into a list containing a as first element, b as second element and c as third element.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        }
      ],
      "php": [
        {
          "signature": "rpush(string $key, array $values)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "array $values",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "LPOP": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def lpop(self,, name: KeyT,, count: Optional[int] = None,)",
          "summary": "",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "count",
              "type": "Optional[int] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Union[str, List, None]], Union[str, List, None]]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String lpop(final String key)",
          "summary": "Atomically return and remove the first (LPOP) or last (RPOP) element of the list. For example",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        },
        {
          "signature": "List<String> lpop(final String key, final int count)",
          "summary": "Atomically return and remove the first (LPOP) or last (RPOP) element of the list. For example",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final int count",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V lpop(K key)",
          "summary": "Remove and get the first {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "@return List&lt;V&gt; array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "List<V> lpop(K key, long count)",
          "summary": "Remove and get the first {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "List<V>",
            "description": "@return List&lt;V&gt; array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> lpop(K key)",
          "summary": "Remove and get the first {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "@return List&lt;V&gt; array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "RedisFuture<List<V>> lpop(K key, long count)",
          "summary": "Remove and get the first {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<V>>",
            "description": "@return List&lt;V&gt; array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> lpop(K key)",
          "summary": "Remove and get the first {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "@return V array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "Flux<V> lpop(K key, long count)",
          "summary": "Remove and get the first {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "@return V array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) LPop(ctx context.Context, key string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "LPOP(parser: CommandParser, key: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "lpop()",
          "summary": "Remove and get the first elements in a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "lpop()",
          "summary": "Remove and get the first elements in a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn lpop(key: K, count: Option<core::num::NonZeroUsize>)",
          "summary": "Removes and returns the up to `count` first elements of the list stored at key. If `count` is not specified, then defaults to first element. [Redis Docs](https://redis.io/commands/LPOP)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "count",
              "type": "Option<core",
              "description": ""
            }
          ],
          "returns": {
            "type": "Generic",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn lpop(key: K, count: Option<core::num::NonZeroUsize>)",
          "summary": "Removes and returns the up to `count` first elements of the list stored at key. If `count` is not specified, then defaults to first element. [Redis Docs](https://redis.io/commands/LPOP)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "count",
              "type": "Option<core",
              "description": ""
            }
          ],
          "returns": {
            "type": "Generic",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListLeftPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey[] keys, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to look through for elements to pop."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ListPopResult",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListLeftPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey[] keys, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to look through for elements to pop."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ListPopResult",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the left side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        }
      ],
      "php": [
        {
          "signature": "lpop(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "RPOP": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def rpop(self,, name: KeyT,, count: Optional[int] = None,)",
          "summary": "",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "count",
              "type": "Optional[int] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Union[str, List, None]], Union[str, List, None]]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String rpop(final String key)",
          "summary": "Atomically return and remove the first (LPOP) or last (RPOP) element of the list. For example",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        },
        {
          "signature": "List<String> rpop(final String key, final int count)",
          "summary": "Atomically return and remove the first (LPOP) or last (RPOP) element of the list. For example",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final int count",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V rpop(K key)",
          "summary": "Remove and get the last {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "List&lt;V&gt; array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "List<V> rpop(K key, long count)",
          "summary": "Remove and get the last {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "List<V>",
            "description": "List&lt;V&gt; array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> rpop(K key)",
          "summary": "Remove and get the last {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "List&lt;V&gt; array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "RedisFuture<List<V>> rpop(K key, long count)",
          "summary": "Remove and get the last {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<V>>",
            "description": "List&lt;V&gt; array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> rpop(K key)",
          "summary": "Remove and get the last {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "Flux<V> rpop(K key, long count)",
          "summary": "Remove and get the last {@code count} elements in a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "V array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) RPop(ctx context.Context, key string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "RPOP(parser: CommandParser, key: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "rpop()",
          "summary": "Remove and get the last elements in a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "rpop()",
          "summary": "Remove and get the last elements in a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn rpop(key: K, count: Option<core::num::NonZeroUsize>)",
          "summary": "Removes and returns the up to `count` last elements of the list stored at key If `count` is not specified, then defaults to last element. [Redis Docs](https://redis.io/commands/RPOP)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "count",
              "type": "Option<core",
              "description": ""
            }
          ],
          "returns": {
            "type": "Generic",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn rpop(key: K, count: Option<core::num::NonZeroUsize>)",
          "summary": "Removes and returns the up to `count` last elements of the list stored at key If `count` is not specified, then defaults to last element. [Redis Docs](https://redis.io/commands/RPOP)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "count",
              "type": "Option<core",
              "description": ""
            }
          ],
          "returns": {
            "type": "Generic",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey[] keys, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to look through for elements to pop."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ListPopResult",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey[] keys, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey[] keys",
              "type": "Any",
              "description": "The keys to look through for elements to pop."
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ListPopResult",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "summary": "elements from the first non-empty list in <paramref name=\"keys\"/>. Starts on the right side of the list.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long count",
              "type": "Any",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        }
      ],
      "php": [
        {
          "signature": "rpop(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "LRANGE": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def lrange(self, name: KeyT, start: int, end: int)",
          "summary": "Return a slice of the list ``name`` between position ``start`` and ``end`` ``start`` and ``end`` can be negative numbers just like Python slicing notation For more information, see https://redis.io/commands/lrange",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "start",
              "type": "int",
              "description": ""
            },
            {
              "name": "end",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[list], list]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> lrange(final String key, final long start, final long stop)",
          "summary": "Return the specified elements of the list stored at the specified key. Start and end are",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long start",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final long stop",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "A list of elements in the specified range"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<V> lrange(K key, long start, long stop)",
          "summary": "Get a range of elements from a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long start",
              "type": "Any",
              "description": "the start type: long."
            },
            {
              "name": "long stop",
              "type": "Any",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "List<V>",
            "description": "Long count of elements in the specified range."
          }
        },
        {
          "signature": "Long lrange(ValueStreamingChannel<V> channel, K key, long start, long stop)",
          "summary": "Get a range of elements from a list.",
          "params": [
            {
              "name": "ValueStreamingChannel<V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long start",
              "type": "Any",
              "description": "the start type: long."
            },
            {
              "name": "long stop",
              "type": "Any",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of elements in the specified range."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<V>> lrange(K key, long start, long stop)",
          "summary": "Get a range of elements from a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long start",
              "type": "Any",
              "description": "the start type: long."
            },
            {
              "name": "long stop",
              "type": "Any",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<V>>",
            "description": "Long count of elements in the specified range."
          }
        },
        {
          "signature": "RedisFuture<Long> lrange(ValueStreamingChannel<V> channel, K key, long start, long stop)",
          "summary": "Get a range of elements from a list.",
          "params": [
            {
              "name": "ValueStreamingChannel<V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long start",
              "type": "Any",
              "description": "the start type: long."
            },
            {
              "name": "long stop",
              "type": "Any",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of elements in the specified range."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<V> lrange(K key, long start, long stop)",
          "summary": "Get a range of elements from a list.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long start",
              "type": "Any",
              "description": "the start type: long."
            },
            {
              "name": "long stop",
              "type": "Any",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "Long count of elements in the specified range. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #lrange}."
          }
        },
        {
          "signature": "Mono<Long> lrange(ValueStreamingChannel<V> channel, K key, long start, long stop)",
          "summary": "Get a range of elements from a list.",
          "params": [
            {
              "name": "ValueStreamingChannel<V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "long start",
              "type": "Any",
              "description": "the start type: long."
            },
            {
              "name": "long stop",
              "type": "Any",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of elements in the specified range. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #lrange}."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) LRange(ctx context.Context, key string, start, stop int64)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "start",
              "type": "Any",
              "description": ""
            },
            {
              "name": "stop int64",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "LRANGE(parser: CommandParser, key: RedisArgument, start: number, stop: number)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "start",
              "type": "number",
              "description": ""
            },
            {
              "name": "stop",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "lrange()",
          "summary": "Get a range of elements from a list",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn lrange(key: K, start: isize, stop: isize)",
          "summary": "Returns the specified elements of the list stored at key. [Redis Docs](https://redis.io/commands/LRANGE)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "start",
              "type": "isize",
              "description": ""
            },
            {
              "name": "stop",
              "type": "isize",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn lrange(key: K, start: isize, stop: isize)",
          "summary": "Returns the specified elements of the list stored at key. [Redis Docs](https://redis.io/commands/LRANGE)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "start",
              "type": "isize",
              "description": ""
            },
            {
              "name": "stop",
              "type": "isize",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListRange(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the specified elements of the list stored at key. The offsets start and stop are zero-based indexes, with 0 being the first element of the list (the head of the list), 1 being the next element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list.For example, -1 is the last element of the list, -2 the penultimate, and so on. Note that if you have a list of numbers from 0 to 100, LRANGE list 0 10 will return 11 elements, that is, the rightmost item is included.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "long start = 0",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long stop = -1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of elements in the specified range."
          }
        },
        {
          "signature": "ListRange(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the specified elements of the list stored at key. The offsets start and stop are zero-based indexes, with 0 being the first element of the list (the head of the list), 1 being the next element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list.For example, -1 is the last element of the list, -2 the penultimate, and so on. Note that if you have a list of numbers from 0 to 100, LRANGE list 0 10 will return 11 elements, that is, the rightmost item is included.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "long start = 0",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long stop = -1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of elements in the specified range."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListRange(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the specified elements of the list stored at key. The offsets start and stop are zero-based indexes, with 0 being the first element of the list (the head of the list), 1 being the next element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list.For example, -1 is the last element of the list, -2 the penultimate, and so on. Note that if you have a list of numbers from 0 to 100, LRANGE list 0 10 will return 11 elements, that is, the rightmost item is included.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "long start = 0",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long stop = -1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of elements in the specified range."
          }
        },
        {
          "signature": "ListRange(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the specified elements of the list stored at key. The offsets start and stop are zero-based indexes, with 0 being the first element of the list (the head of the list), 1 being the next element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list.For example, -1 is the last element of the list, -2 the penultimate, and so on. Note that if you have a list of numbers from 0 to 100, LRANGE list 0 10 will return 11 elements, that is, the rightmost item is included.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the list."
            },
            {
              "name": "long start = 0",
              "type": "Any",
              "description": ""
            },
            {
              "name": "long stop = -1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of elements in the specified range."
          }
        }
      ],
      "php": [
        {
          "signature": "lrange(string $key, int $start, int $stop)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "int $start",
              "type": "Any",
              "description": ""
            },
            {
              "name": "int $stop",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string[]",
            "description": ""
          }
        }
      ]
    }
  },
  "HSET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def hset(self,, name: str,, key: Optional[str] = None,, value: Optional[str] = None,, mapping: Optional[dict] = None,, items: Optional[list] = None,)",
          "summary": "",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "value",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "mapping",
              "type": "Optional[dict] = None",
              "description": ""
            },
            {
              "name": "items",
              "type": "Optional[list] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hset(final byte[] key, final byte[] field, final byte[] value)",
          "summary": "Set the specified hash field to the specified value.",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final byte[] field",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final byte[] value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final byte[] key, final Map<byte[], byte[]> hash)",
          "summary": "Set the specified hash field to the specified value.",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final Map<byte[]",
              "type": "Any",
              "description": ""
            },
            {
              "name": "byte[]> hash",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final String key, final String field, final String value)",
          "summary": "Set the specified hash field to the specified value.",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final String field",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final String value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final String key, final Map<String, String> hash)",
          "summary": "Set the specified hash field to the specified value.",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final Map<String",
              "type": "Any",
              "description": ""
            },
            {
              "name": "String> hash",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean hset(K key, K field, V value)",
          "summary": "Set multiple hash fields to multiple values.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key of the hash."
            },
            {
              "name": "K field",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "Long hset(K key, Map<K, V> map)",
          "summary": "Set multiple hash fields to multiple values.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key of the hash."
            },
            {
              "name": "Map<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> map",
              "type": "Any",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> hset(K key, K field, V value)",
          "summary": "Set multiple hash fields to multiple values.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key of the hash."
            },
            {
              "name": "K field",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "RedisFuture<Long> hset(K key, Map<K, V> map)",
          "summary": "Set multiple hash fields to multiple values.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key of the hash."
            },
            {
              "name": "Map<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> map",
              "type": "Any",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> hset(K key, K field, V value)",
          "summary": "Set multiple hash fields to multiple values.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key of the hash."
            },
            {
              "name": "K field",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "Mono<Long> hset(K key, Map<K, V> map)",
          "summary": "Set multiple hash fields to multiple values.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key of the hash."
            },
            {
              "name": "Map<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> map",
              "type": "Any",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) HSet(ctx context.Context, key string, values ...interface{})",
          "summary": "HSet accepts values in following formats:",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "values ...interface{}",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HSET(parser: CommandParser, ...[key, value, fieldValue]: SingleFieldArguments | MultipleFieldsArguments)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "...[key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "fieldValue]",
              "type": "SingleFieldArguments | MultipleFieldsArguments",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hset()",
          "summary": "Set the string value of a hash field",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "summary": "Set the string value of a hash field",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "summary": "Set the string value of a hash field",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "summary": "Set the string value of a hash field",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn hset(key: K, field: F, value: V)",
          "summary": "Sets a single field in a hash. Returns number of fields added. [Redis Docs](https://redis.io/commands/HSET)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn hset(key: K, field: F, value: V)",
          "summary": "Sets a single field in a hash. Returns number of fields added. [Redis Docs](https://redis.io/commands/HSET)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "HashEntry[] hashFields",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue hashField",
              "type": "Any",
              "description": "The field to set in the hash."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": "The value to set."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue hashField",
              "type": "Any",
              "description": "The field to set in the hash."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": "The value to set."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "HashEntry[] hashFields",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "HashEntry[] hashFields",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue hashField",
              "type": "Any",
              "description": "The field to set in the hash."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": "The value to set."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue hashField",
              "type": "Any",
              "description": "The field to set in the hash."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": "The value to set."
            },
            {
              "name": "When when = When.Always",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "summary": "Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "HashEntry[] hashFields",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        }
      ],
      "php": [
        {
          "signature": "hset(string $key, string $field, string $value)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "string $field",
              "type": "Any",
              "description": ""
            },
            {
              "name": "string $value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HGET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def hget(self, name: str, key: str)",
          "summary": "",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Optional[str]], Optional[str]]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String hget(final String key, final String field)",
          "summary": "If key holds a hash, retrieve the value associated to the specified field.",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final String field",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V hget(K key, K field)",
          "summary": "Get the value of a hash field.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "K field",
              "type": "Any",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the value associated with {@code field}, or {@code null} when {@code field} is not present in the hash or {@code key} does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> hget(K key, K field)",
          "summary": "Get the value of a hash field.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "K field",
              "type": "Any",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the value associated with {@code field}, or {@code null} when {@code field} is not present in the hash or {@code key} does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> hget(K key, K field)",
          "summary": "Get the value of a hash field.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "K field",
              "type": "Any",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the value associated with {@code field}, or {@code null} when {@code field} is not present in the hash or {@code key} does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) HGet(ctx context.Context, key, field string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "field string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HGET(parser: CommandParser, key: RedisArgument, field: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "field",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hget()",
          "summary": "Get the value of a hash field",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn hget(key: K, field: F)",
          "summary": "Gets a single (or multiple) fields from a hash.",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn hget(key: K, field: F)",
          "summary": "Gets a single (or multiple) fields from a hash.",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a <see langword=\"RedisValue.Null\"/> value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of <see langword=\"RedisValue.Null\"/> values.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue hashField",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a <see langword=\"RedisValue.Null\"/> value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of <see langword=\"RedisValue.Null\"/> values.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue[] hashFields",
              "type": "Any",
              "description": "The fields in the hash to get."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a <see langword=\"RedisValue.Null\"/> value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of <see langword=\"RedisValue.Null\"/> values.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue hashField",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a <see langword=\"RedisValue.Null\"/> value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of <see langword=\"RedisValue.Null\"/> values.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue[] hashFields",
              "type": "Any",
              "description": "The fields in the hash to get."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a <see langword=\"RedisValue.Null\"/> value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of <see langword=\"RedisValue.Null\"/> values.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue hashField",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a <see langword=\"RedisValue.Null\"/> value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of <see langword=\"RedisValue.Null\"/> values.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue[] hashFields",
              "type": "Any",
              "description": "The fields in the hash to get."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a <see langword=\"RedisValue.Null\"/> value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of <see langword=\"RedisValue.Null\"/> values.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue hashField",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a <see langword=\"RedisValue.Null\"/> value is returned. Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of <see langword=\"RedisValue.Null\"/> values.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "RedisValue[] hashFields",
              "type": "Any",
              "description": "The fields in the hash to get."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "php": [
        {
          "signature": "hget(string $key, string $field)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "string $field",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HGETALL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def hgetall(self, name: str)",
          "summary": "Return a Python dict of the hash's name/value pairs For more information, see https://redis.io/commands/hgetall",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[dict], dict]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "Map<String, String> hgetAll(final String key)",
          "summary": "Return all the fields and associated values in a hash.",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Map<String, String>",
            "description": "All the fields and values contained into a hash."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Map<K, V> hgetall(K key)",
          "summary": "Stream over all the fields and values in a hash.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Map<K, V>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "Long hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "summary": "Stream over all the fields and values in a hash.",
          "params": [
            {
              "name": "KeyValueStreamingChannel<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Map<K, V>> hgetall(K key)",
          "summary": "Stream over all the fields and values in a hash.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Map<K, V>>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "RedisFuture<Long> hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "summary": "Stream over all the fields and values in a hash.",
          "params": [
            {
              "name": "KeyValueStreamingChannel<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> hgetall(K key)",
          "summary": "Stream over all the fields and values in a hash.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #hgetall}."
          }
        },
        {
          "signature": "Mono<Long> hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "summary": "Stream over all the fields and values in a hash.",
          "params": [
            {
              "name": "KeyValueStreamingChannel<K",
              "type": "Any",
              "description": ""
            },
            {
              "name": "V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #hgetall}."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) HGetAll(ctx context.Context, key string)",
          "summary": "",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*MapStringStringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HGETALL(parser: CommandParser, key: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hgetall()",
          "summary": "Get all the fields and values in a hash",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn hgetall(key: K)",
          "summary": "Gets all the fields and values in a hash. [Redis Docs](https://redis.io/commands/HGETALL)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(std::collections::HashMap<String, String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn hgetall(key: K)",
          "summary": "Gets all the fields and values in a hash. [Redis Docs](https://redis.io/commands/HGETALL)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(std::collections::HashMap<String, String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns all fields and values of the hash stored at key.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns all fields and values of the hash stored at key.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns all fields and values of the hash stored at key.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns all fields and values of the hash stored at key.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hgetall(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "SADD": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def sadd(self, name: KeyT, *values: FieldT)",
          "summary": "Add ``value(s)`` to set ``name`` For more information, see https://redis.io/commands/sadd",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "*values",
              "type": "FieldT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long sadd(final byte[] key, final byte[]... members)",
          "summary": "Add the specified member to the set value stored at key. If member is already a member of the",
          "params": [
            {
              "name": "final byte[] key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final byte[]... members",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the new element was added, 0 if the element was already a member of the set"
          }
        },
        {
          "signature": "long sadd(final String key, final String... members)",
          "summary": "Add the specified member to the set value stored at key. If member is already a member of the",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "final String... members",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the new element was added, 0 if the element was already a member of the set"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long sadd(K key, V... members)",
          "summary": "Add one or more members to a set.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... members",
              "type": "Any",
              "description": "the member type: value."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> sadd(K key, V... members)",
          "summary": "Add one or more members to a set.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... members",
              "type": "Any",
              "description": "the member type: value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> sadd(K key, V... members)",
          "summary": "Add one or more members to a set.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the key."
            },
            {
              "name": "V... members",
              "type": "Any",
              "description": "the member type: value."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) SAdd(ctx context.Context, key string, members ...interface{})",
          "summary": "Returns the number of elements that were added to the set, not including all",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            },
            {
              "name": "members ...interface{}",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SADD(parser: CommandParser, key: RedisArgument, members: RedisVariadicArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "members",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "sadd()",
          "summary": "Add one or more members to a set",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "sadd()",
          "summary": "Add one or more members to a set",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "sadd()",
          "summary": "Add one or more members to a set",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "sadd()",
          "summary": "Add one or more members to a set",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn sadd(key: K, member: M)",
          "summary": "Add one or more members to a set. [Redis Docs](https://redis.io/commands/SADD)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "member",
              "type": "M",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn sadd(key: K, member: M)",
          "summary": "Add one or more members to a set. [Redis Docs](https://redis.io/commands/SADD)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "member",
              "type": "M",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "SetAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "summary": "Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None)",
          "summary": "Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "summary": "Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None)",
          "summary": "Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "SetAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "summary": "Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None)",
          "summary": "Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "summary": "Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "RedisValue value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None)",
          "summary": "Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "RedisValue[] values",
              "type": "Any",
              "description": "The values to add to the set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "php": [
        {
          "signature": "sadd(string $key, array $members)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "array $members",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "SMEMBERS": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "def smembers(self, name: KeyT)",
          "summary": "Return all members of the set ``name`` For more information, see https://redis.io/commands/smembers",
          "params": [
            {
              "name": "self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Set], Set]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "Set<String> smembers(final String key)",
          "summary": "Return all the members (elements) of the set value stored at key. This is just syntax glue for",
          "params": [
            {
              "name": "final String key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Set<String>",
            "description": "Multi bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Set<V> smembers(K key)",
          "summary": "Get all the members in a set.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Set<V>",
            "description": "Long count of members of the resulting set."
          }
        },
        {
          "signature": "Long smembers(ValueStreamingChannel<V> channel, K key)",
          "summary": "Get all the members in a set.",
          "params": [
            {
              "name": "ValueStreamingChannel<V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of members of the resulting set."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Set<V>> smembers(K key)",
          "summary": "Get all the members in a set.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Set<V>>",
            "description": "Long count of members of the resulting set."
          }
        },
        {
          "signature": "RedisFuture<Long> smembers(ValueStreamingChannel<V> channel, K key)",
          "summary": "Get all the members in a set.",
          "params": [
            {
              "name": "ValueStreamingChannel<V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of members of the resulting set."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<V> smembers(K key)",
          "summary": "Get all the members in a set.",
          "params": [
            {
              "name": "K key",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "Long count of members of the resulting set. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #smembers}."
          }
        },
        {
          "signature": "Mono<Long> smembers(ValueStreamingChannel<V> channel, K key)",
          "summary": "Get all the members in a set.",
          "params": [
            {
              "name": "ValueStreamingChannel<V> channel",
              "type": "Any",
              "description": "the channel."
            },
            {
              "name": "K key",
              "type": "Any",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of members of the resulting set. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #smembers}."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "func (c cmdable) SMembers(ctx context.Context, key string)",
          "summary": "Returns all the members of the set value stored at key.",
          "params": [
            {
              "name": "ctx context.Context",
              "type": "Any",
              "description": ""
            },
            {
              "name": "key string",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SMEMBERS(parser: CommandParser, key: RedisArgument)",
          "summary": "",
          "params": [
            {
              "name": "parser",
              "type": "CommandParser",
              "description": ""
            },
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "smembers()",
          "summary": "Get all the members in a set",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "fn smembers(key: K)",
          "summary": "Get all the members in a set. [Redis Docs](https://redis.io/commands/SMEMBERS)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(HashSet<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "fn smembers(key: K)",
          "summary": "Get all the members in a set. [Redis Docs](https://redis.io/commands/SMEMBERS)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(HashSet<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "SetMembers(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns all the members of the set value stored at key.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "All elements of the set."
          }
        },
        {
          "signature": "SetMembers(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns all the members of the set value stored at key.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "All elements of the set."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "SetMembers(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns all the members of the set value stored at key.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "All elements of the set."
          }
        },
        {
          "signature": "SetMembers(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "summary": "Returns all the members of the set value stored at key.",
          "params": [
            {
              "name": "RedisKey key",
              "type": "Any",
              "description": "The key of the set."
            },
            {
              "name": "CommandFlags flags = CommandFlags.None",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "All elements of the set."
          }
        }
      ],
      "php": [
        {
          "signature": "smembers(string $key)",
          "summary": "",
          "params": [
            {
              "name": "string $key",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string[]",
            "description": ""
          }
        }
      ]
    }
  }
}