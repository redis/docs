{
  "GET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "get(fmt: str, offset: BitfieldOffsetT)",
          "params": [
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "get(name: KeyT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String get(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V get(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the value of {@code key}, or {@code null} when {@code key} does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> get(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the value of {@code key}, or {@code null} when {@code key} does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> get(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the value of {@code key}, or {@code null} when {@code key} does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Get(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "GET(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "get()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "get(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        },
        {
          "signature": "get(mut self, get: bool)",
          "params": [
            {
              "name": "mut self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "Self",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "get(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        },
        {
          "signature": "get(mut self, get: bool)",
          "params": [
            {
              "name": "mut self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "Self",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys of the strings."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(key, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys of the strings."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys of the strings."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(key, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys of the strings."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with <see cref=\"RedisValue.Null\"/> for keys do not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "get(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "SET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "set(fmt: str, offset: BitfieldOffsetT, value: int)",
          "params": [
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            },
            {
              "name": "value",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set(, name: KeyT,, value: EncodableT,, ex: Optional[ExpiryT] = None,, px: Optional[ExpiryT] = None,, nx: bool = False,, xx: bool = False,, keepttl: bool = False,, get: bool = False,, exat: Optional[AbsExpiryT] = None,, pxat: Optional[AbsExpiryT] = None,, ifeq: Optional[Union[bytes, str]] = None,, ifne: Optional[Union[bytes, str]] = None,, ifdeq: Optional[str] = None,  # hex digest of current value, ifdne: Optional[str] = None,  # hex digest of current value)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            },
            {
              "name": "ex",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "px",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "keepttl",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "exat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "pxat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "ifeq",
              "type": "Optional[Union[bytes",
              "description": ""
            },
            {
              "name": "str]] = None",
              "type": "Any",
              "description": ""
            },
            {
              "name": "ifne",
              "type": "Optional[Union[bytes",
              "description": ""
            },
            {
              "name": "str]] = None",
              "type": "Any",
              "description": ""
            },
            {
              "name": "ifdeq",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "# hex digest of current value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "ifdne",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "# hex digest of current value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String set(final byte[] key, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply {@code OK} if {@code SET} was executed correctly, or {@code null} if the {@code SET} operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final byte[] key, final byte[] value, final SetParams params)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "params",
              "type": "SetParams",
              "description": "key if it already exists. EX|PX, expire time units: EX = seconds; PX = milliseconds"
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply {@code OK} if {@code SET} was executed correctly, or {@code null} if the {@code SET} operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final String key, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply {@code OK} if {@code SET} was executed correctly, or {@code null} if the {@code SET} operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final String key, final String value, final SetParams params)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            },
            {
              "name": "params",
              "type": "SetParams",
              "description": "key if it already exists. EX|PX, expire time units: EX = seconds; PX = milliseconds"
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply {@code OK} if {@code SET} was executed correctly, or {@code null} if the {@code SET} operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String set(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        },
        {
          "signature": "String set(K key, V value, SetArgs setArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            },
            {
              "name": "setArgs",
              "type": "SetArgs",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> set(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        },
        {
          "signature": "RedisFuture<String> set(K key, V value, SetArgs setArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            },
            {
              "name": "setArgs",
              "type": "SetArgs",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> set(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        },
        {
          "signature": "Mono<String> set(K key, V value, SetArgs setArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            },
            {
              "name": "setArgs",
              "type": "SetArgs",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply {@code OK} if {@code SET} was executed correctly."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Set(ctx context.Context, key string, value interface{}, expiration time.Duration)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "interface{}",
              "description": ""
            },
            {
              "name": "expiration",
              "type": "time.Duration",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StatusCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SET(key: RedisArgument, value: RedisArgument | number, options?: SetOptions)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument | number",
              "description": ""
            },
            {
              "name": "options?",
              "type": "SetOptions",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "set(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "set(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, bool keepTtl, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "keepTtl",
              "type": "bool",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, Expiration expiry = default, ValueCondition when = default, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "Expiration",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "ValueCondition",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(KeyValuePair<RedisKey, RedisValue>[] values, When when, CommandFlags flags)",
          "params": [
            {
              "name": "values",
              "type": "KeyValuePair<RedisKey, RedisValue>[]",
              "description": "The keys and values to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, bool keepTtl, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "keepTtl",
              "type": "bool",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, Expiration expiry = default, ValueCondition when = default, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "Expiration",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "ValueCondition",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(KeyValuePair<RedisKey, RedisValue>[] values, When when, CommandFlags flags)",
          "params": [
            {
              "name": "values",
              "type": "KeyValuePair<RedisKey, RedisValue>[]",
              "description": "The keys and values to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        }
      ],
      "php": [
        {
          "signature": "set(string $key, $value, $expireResolution = null, $expireTTL = null, $flag = null, $flagValue = null)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$expireResolution = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$expireTTL = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$flag = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$flagValue = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Status|null",
            "description": ""
          }
        }
      ]
    }
  },
  "MGET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "mget(keys: KeysT, *args: EncodableT)",
          "params": [
            {
              "name": "keys",
              "type": "KeysT",
              "description": ""
            },
            {
              "name": "*args",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> mget(final String... keys)",
          "params": [
            {
              "name": "keys",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Multi bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<KeyValue<K, V>> mget(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "List<KeyValue<K, V>>",
            "description": "Long array-reply list of values at the specified keys."
          }
        },
        {
          "signature": "Long mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long array-reply list of values at the specified keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<KeyValue<K, V>>> mget(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<KeyValue<K, V>>>",
            "description": "Long array-reply list of values at the specified keys."
          }
        },
        {
          "signature": "RedisFuture<Long> mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long array-reply list of values at the specified keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> mget(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long array-reply list of values at the specified keys. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #mget}."
          }
        },
        {
          "signature": "Mono<Long> mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long array-reply list of values at the specified keys. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #mget}."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "MGet(ctx context.Context, keys ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "keys",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*SliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "MGET(keys: Array<RedisArgument>)",
          "params": [
            {
              "name": "keys",
              "type": "Array<RedisArgument>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "mget()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mget()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mget(...args: [...keys: RedisKey[]])",
          "params": [
            {
              "name": "...args",
              "type": "[...keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<(string | null)[], Context>",
            "description": ""
          }
        },
        {
          "signature": "mget(...args: [keys: RedisKey[]])",
          "params": [
            {
              "name": "...args",
              "type": "[keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<(string | null)[], Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "mget(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<Option<String>>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "mget(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<Option<String>>)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "mget(string[]|string $keyOrKeys, string ...$keys = null)",
          "params": [
            {
              "name": "$keyOrKeys",
              "type": "string[]|string",
              "description": ""
            },
            {
              "name": "string ...$keys = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "MSET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "mset(mapping: Mapping[AnyKeyT, EncodableT])",
          "params": [
            {
              "name": "mapping",
              "type": "Mapping[AnyKeyT",
              "description": ""
            },
            {
              "name": "EncodableT]",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String mset(final byte[]... keysvalues)",
          "params": [
            {
              "name": "keysvalues",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK"
          }
        },
        {
          "signature": "String mset(final String... keysvalues)",
          "params": [
            {
              "name": "keysvalues",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String mset(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply always {@code OK} since {@code MSET} can't fail."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> mset(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply always {@code OK} since {@code MSET} can't fail."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> mset(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply always {@code OK} since {@code MSET} can't fail."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "MSet(ctx context.Context, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StatusCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "MSET(toSet: MSetArguments)",
          "params": [
            {
              "name": "toSet",
              "type": "MSetArguments",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "mset(object: object, callback?: Callback<\"OK\">)",
          "params": [
            {
              "name": "object",
              "type": "object",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<\"OK\">",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<\"OK\", Context>",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "mset(items: &'a [(K, V)])",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K",
              "description": ""
            },
            {
              "name": "V)]",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "mset(items: &'a [(K, V)])",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K",
              "description": ""
            },
            {
              "name": "V)]",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "mset(array $dictionary)",
          "params": [
            {
              "name": "$dictionary",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "mixed",
            "description": ""
          }
        }
      ]
    }
  },
  "INCR": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "incrby(, fmt: str,, offset: BitfieldOffsetT,, increment: int,, overflow: Optional[str] = None,)",
          "params": [
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            },
            {
              "name": "increment",
              "type": "int",
              "description": ""
            },
            {
              "name": "overflow",
              "type": "Optional[str] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "incrby(name: KeyT, amount: int = 1)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long incrBy(final byte[] key, final long increment)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "increment",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incr(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incrBy(final String key, final long increment)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "increment",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incr(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        },
        {
          "signature": "Long incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        },
        {
          "signature": "RedisFuture<Long> incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        },
        {
          "signature": "Mono<Long> incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of {@code key} after the increment."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Incr(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        },
        {
          "signature": "IncrBy(ctx context.Context, key string, value int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "INCR(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "incr(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "incrby()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "incr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "incr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "php": [
        {
          "signature": "incr(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        },
        {
          "signature": "incrby(string $key, int $increment)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$increment",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "DECR": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "decrby(name: KeyT, amount: int = 1)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long decrBy(final byte[] key, final long decrement)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decr(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decrBy(final String key, final long decrement)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decr(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        },
        {
          "signature": "Long decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        },
        {
          "signature": "RedisFuture<Long> decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        },
        {
          "signature": "Mono<Long> decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of {@code key} after the decrement."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Decr(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        },
        {
          "signature": "DecrBy(ctx context.Context, key string, decrement int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "DECR(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "decr(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "decrby()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "decr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "decr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        }
      ],
      "php": [
        {
          "signature": "decr(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        },
        {
          "signature": "decrby(string $key, int $decrement)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$decrement",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "DEL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "delete(*names: KeyT)",
          "params": [
            {
              "name": "*names",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long del(final byte[]... keys)",
          "params": [
            {
              "name": "keys",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "An integer greater than 0 if one or more keys were removed, 0 if none of the specified keys existed"
          }
        },
        {
          "signature": "long del(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "An integer greater than 0 if one or more keys were removed, 0 if none of the specified keys existed"
          }
        },
        {
          "signature": "long del(final String... keys)",
          "params": [
            {
              "name": "keys",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "An integer greater than 0 if one or more keys were removed, 0 if none of the specified keys existed"
          }
        },
        {
          "signature": "long del(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "An integer greater than 0 if one or more keys were removed, 0 if none of the specified keys existed"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long del(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply The number of keys that were removed."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> del(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply The number of keys that were removed."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> del(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply The number of keys that were removed."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Del(ctx context.Context, keys ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "keys",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "DEL(keys: RedisVariadicArgument)",
          "params": [
            {
              "name": "keys",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "del()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "del()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "del(...args: [...keys: RedisKey[]])",
          "params": [
            {
              "name": "...args",
              "type": "[...keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "del(...args: [keys: RedisKey[]])",
          "params": [
            {
              "name": "...args",
              "type": "[keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "del(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "del(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to delete."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to delete."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(key, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The number of keys that were removed."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to delete."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to delete."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that were removed."
          }
        },
        {
          "signature": "KeyDelete(key, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The number of keys that were removed."
          }
        }
      ],
      "php": [
        {
          "signature": "del(string[]|string $keyOrKeys, string ...$keys = null)",
          "params": [
            {
              "name": "$keyOrKeys",
              "type": "string[]|string",
              "description": ""
            },
            {
              "name": "string ...$keys = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "EXISTS": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "exists(*names: KeyT)",
          "params": [
            {
              "name": "*names",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long exists(final byte[]... keys)",
          "params": [
            {
              "name": "keys",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "{@code true} if the key exists, otherwise {@code false}"
          }
        },
        {
          "signature": "boolean exists(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "boolean",
            "description": "{@code true} if the key exists, otherwise {@code false}"
          }
        },
        {
          "signature": "long exists(final String... keys)",
          "params": [
            {
              "name": "keys",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "{@code true} if the key exists, otherwise {@code false}"
          }
        },
        {
          "signature": "boolean exists(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "boolean",
            "description": "{@code true} if the key exists, otherwise {@code false}"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long exists(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply specifically: Number of existing keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> exists(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply specifically: Number of existing keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> exists(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply specifically: Number of existing keys."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Exists(ctx context.Context, keys ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "keys",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "EXISTS(keys: RedisVariadicArgument)",
          "params": [
            {
              "name": "keys",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "exists()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "exists()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "exists(...args: [...keys: RedisKey[]])",
          "params": [
            {
              "name": "...args",
              "type": "[...keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "exists(...args: [keys: RedisKey[]])",
          "params": [
            {
              "name": "...args",
              "type": "[keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "exists(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "exists(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that existed."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of keys that existed."
          }
        },
        {
          "signature": "KeyExists(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of keys that existed."
          }
        }
      ],
      "php": [
        {
          "signature": "exists(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "EXPIRE": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "expire(, name: KeyT,, time: ExpiryT,, nx: bool = False,, xx: bool = False,, gt: bool = False,, lt: bool = False,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "time",
              "type": "ExpiryT",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "gt",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "lt",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long expire(final byte[] key, final long seconds)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "time to expire"
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the timeout was set, 0 otherwise. Since the key already has an associated timeout (this may happen only in Redis versions &lt; 2.1.3, Redis &gt;= 2.1.3 will happily update the timeout), or the key does not exist."
          }
        },
        {
          "signature": "long expire(final byte[] key, final long seconds, final ExpiryOption expiryOption)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "time to expire"
            },
            {
              "name": "expiryOption",
              "type": "ExpiryOption",
              "description": "can be NX, XX, GT or LT"
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the timeout was set, 0 otherwise. Since the key already has an associated timeout (this may happen only in Redis versions &lt; 2.1.3, Redis &gt;= 2.1.3 will happily update the timeout), or the key does not exist."
          }
        },
        {
          "signature": "long expire(final String key, final long seconds)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "time to expire"
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the timeout was set, 0 otherwise. Since the key already has an associated timeout (this may happen only in Redis versions &lt; 2.1.3, Redis &gt;= 2.1.3 will happily update the timeout), or the key does not exist."
          }
        },
        {
          "signature": "long expire(final String key, final long seconds, final ExpiryOption expiryOption)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "time to expire"
            },
            {
              "name": "expiryOption",
              "type": "ExpiryOption",
              "description": "can be NX, XX, GT or LT"
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the timeout was set, 0 otherwise. Since the key already has an associated timeout (this may happen only in Redis versions &lt; 2.1.3, Redis &gt;= 2.1.3 will happily update the timeout), or the key does not exist."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean expire(K key, long seconds)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Boolean expire(K key, long seconds, ExpireArgs expireArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Boolean expire(K key, Duration seconds)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Boolean expire(K key, Duration seconds, ExpireArgs expireArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the seconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> expire(K key, long seconds)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "RedisFuture<Boolean> expire(K key, long seconds, ExpireArgs expireArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "RedisFuture<Boolean> expire(K key, Duration seconds)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "RedisFuture<Boolean> expire(K key, Duration seconds, ExpireArgs expireArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the seconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> expire(K key, long seconds)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Mono<Boolean> expire(K key, long seconds, ExpireArgs expireArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Mono<Boolean> expire(K key, Duration seconds)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the seconds."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        },
        {
          "signature": "Mono<Boolean> expire(K key, Duration seconds, ExpireArgs expireArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the seconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: {@code true} if the timeout was set. {@code false} if {@code key} does not exist or the timeout could not be set. @since 6.2"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Expire(ctx context.Context, key string, expiration time.Duration)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "expiration",
              "type": "time.Duration",
              "description": ""
            }
          ],
          "returns": {
            "type": "*BoolCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "EXPIRE()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "expire()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "expire()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "expire()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "expire()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "expire()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "expire(key: K, seconds: i64)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "i64",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "expire(key: K, seconds: i64)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "i64",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The timeout to set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The timeout to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "In Redis 7+, we choose under which condition the expiration will be set using <see cref=\"ExpireWhen\"/>."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, DateTime? expiry, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "DateTime?",
              "description": "The timeout to set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, DateTime? expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "DateTime?",
              "description": "The timeout to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "In Redis 7+, we choose under which condition the expiration will be set using <see cref=\"ExpireWhen\"/>."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The timeout to set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The timeout to set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The timeout to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "In Redis 7+, we choose under which condition the expiration will be set using <see cref=\"ExpireWhen\"/>."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, DateTime? expiry, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "DateTime?",
              "description": "The timeout to set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, DateTime? expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "DateTime?",
              "description": "The timeout to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "In Redis 7+, we choose under which condition the expiration will be set using <see cref=\"ExpireWhen\"/>."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        },
        {
          "signature": "KeyExpire(RedisKey key, TimeSpan? expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to set the expiration for."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The timeout to set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the timeout was set. <see langword=\"false\"/> if key does not exist or the timeout could not be set."
          }
        }
      ],
      "php": [
        {
          "signature": "expire(string $key, int $seconds, string $expireOption = '')",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$seconds",
              "type": "int",
              "description": ""
            },
            {
              "name": "string $expireOption = ''",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "TTL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "ttl(name: KeyT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long ttl(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "TTL in seconds, or a negative value in order to signal an error"
          }
        },
        {
          "signature": "long ttl(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "TTL in seconds, or a negative value in order to signal an error"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long ttl(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply TTL in seconds, or a negative value in order to signal an error. The command returns {@code -1} if the key exists but has no associated expiration time. The command returns {@code -2} if the key does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> ttl(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply TTL in seconds, or a negative value in order to signal an error. The command returns {@code -1} if the key exists but has no associated expiration time. The command returns {@code -2} if the key does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> ttl(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply TTL in seconds, or a negative value in order to signal an error. The command returns {@code -1} if the key exists but has no associated expiration time. The command returns {@code -2} if the key does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "TTL(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*DurationCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "TTL(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "ttl(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "ttl(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(IntegerReplyOrNoOp)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "ttl(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(IntegerReplyOrNoOp)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "KeyTimeToLive(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "TimeSpan?",
            "description": "TTL, or <see langword=\"null\"/> when key does not exist or does not have a timeout."
          }
        },
        {
          "signature": "KeyTimeToLive(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "TimeSpan?",
            "description": "TTL, or <see langword=\"null\"/> when key does not exist or does not have a timeout."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "KeyTimeToLive(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "TimeSpan?",
            "description": "TTL, or <see langword=\"null\"/> when key does not exist or does not have a timeout."
          }
        },
        {
          "signature": "KeyTimeToLive(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "TimeSpan?",
            "description": "TTL, or <see langword=\"null\"/> when key does not exist or does not have a timeout."
          }
        }
      ],
      "php": [
        {
          "signature": "ttl(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "LPUSH": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "lpush(name: KeyT, *values: FieldT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "*values",
              "type": "FieldT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long lpush(final byte[] key, final byte[]... strings)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "strings",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements inside the list after the push operation"
          }
        },
        {
          "signature": "long lpush(final String key, final String... strings)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "strings",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements inside the list after the push operation"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long lpush(K key, V... values)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "values",
              "type": "V...",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the length of the list after the push operations."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> lpush(K key, V... values)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "values",
              "type": "V...",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the length of the list after the push operations."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> lpush(K key, V... values)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "values",
              "type": "V...",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the length of the list after the push operations."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "LPush(ctx context.Context, key string, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "LPUSH(key: RedisArgument, elements: RedisVariadicArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "elements",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "lpush()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "lpush()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "lpush(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "lpush(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        },
        {
          "signature": "ListLeftPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the head of the list."
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operations."
          }
        }
      ],
      "php": [
        {
          "signature": "lpush(string $key, array $values)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$values",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "RPUSH": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "rpush(name: KeyT, *values: FieldT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "*values",
              "type": "FieldT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long rpush(final byte[] key, final byte[]... strings)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "strings",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements inside the list after the push operation"
          }
        },
        {
          "signature": "long rpush(final String key, final String... strings)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "strings",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements inside the list after the push operation"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long rpush(K key, V... values)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "values",
              "type": "V...",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the length of the list after the push operation."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> rpush(K key, V... values)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "values",
              "type": "V...",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the length of the list after the push operation."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> rpush(K key, V... values)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "values",
              "type": "V...",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the length of the list after the push operation."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "RPush(ctx context.Context, key string, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "RPUSH(key: RedisArgument, element: RedisVariadicArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "element",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "rpush()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "rpush()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "rpush(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "rpush(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListRightPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListRightPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        },
        {
          "signature": "ListRightPush(RedisKey key, RedisValue[] values, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the tail of the list."
            },
            {
              "name": "when",
              "type": "When",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the list after the push operation."
          }
        }
      ],
      "php": [
        {
          "signature": "rpush(string $key, array $values)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$values",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "LPOP": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "lpop(, name: KeyT,, count: Optional[int] = None,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "count",
              "type": "Optional[int] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Union[str, List, None]], Union[str, List, None]]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String lpop(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        },
        {
          "signature": "List<String> lpop(final String key, final int count)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "count",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V lpop(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "@return List&lt;V&gt; array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "List<V> lpop(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "List<V>",
            "description": "@return List&lt;V&gt; array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> lpop(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "@return List&lt;V&gt; array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "RedisFuture<List<V>> lpop(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<V>>",
            "description": "@return List&lt;V&gt; array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> lpop(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "@return V array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "Flux<V> lpop(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "@return V array-reply list of the first {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "LPop(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "LPOP(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "lpop()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "lpop()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "lpop(key: K, count: Option<core::num::NonZeroUsize>)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "count",
              "type": "Option<core",
              "description": ""
            }
          ],
          "returns": {
            "type": "Generic",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "lpop(key: K, count: Option<core::num::NonZeroUsize>)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "count",
              "type": "Option<core",
              "description": ""
            }
          ],
          "returns": {
            "type": "Generic",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListLeftPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey[] keys, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to look through for elements to pop."
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ListPopResult",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListLeftPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey[] keys, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to look through for elements to pop."
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ListPopResult",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListLeftPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        }
      ],
      "php": [
        {
          "signature": "lpop(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "RPOP": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "rpop(, name: KeyT,, count: Optional[int] = None,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "count",
              "type": "Optional[int] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Union[str, List, None]], Union[str, List, None]]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String rpop(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        },
        {
          "signature": "List<String> rpop(final String key, final int count)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "count",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V rpop(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "List&lt;V&gt; array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "List<V> rpop(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "List<V>",
            "description": "List&lt;V&gt; array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> rpop(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "List&lt;V&gt; array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "RedisFuture<List<V>> rpop(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<V>>",
            "description": "List&lt;V&gt; array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> rpop(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        },
        {
          "signature": "Flux<V> rpop(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "the number of elements to return."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "V array-reply list of the last {@code count} elements, or {@code null} when {@code key} does not exist. @since 6.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "RPop(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "RPOP(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "rpop()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "rpop()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "rpop(key: K, count: Option<core::num::NonZeroUsize>)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "count",
              "type": "Option<core",
              "description": ""
            }
          ],
          "returns": {
            "type": "Generic",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "rpop(key: K, count: Option<core::num::NonZeroUsize>)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "count",
              "type": "Option<core",
              "description": ""
            }
          ],
          "returns": {
            "type": "Generic",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey[] keys, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to look through for elements to pop."
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ListPopResult",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey[] keys, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys to look through for elements to pop."
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ListPopResult",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        },
        {
          "signature": "ListRightPop(RedisKey key, long count, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": "The maximum number of elements to pop from the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "A span of contiguous elements from the list, or <see cref=\"ListPopResult.Null\"/> if no non-empty lists are found."
          }
        }
      ],
      "php": [
        {
          "signature": "rpop(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "LRANGE": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "lrange(name: KeyT, start: int, end: int)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "start",
              "type": "int",
              "description": ""
            },
            {
              "name": "end",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[list], list]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> lrange(final String key, final long start, final long stop)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "start",
              "type": "long",
              "description": ""
            },
            {
              "name": "stop",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "A list of elements in the specified range"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<V> lrange(K key, long start, long stop)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "List<V>",
            "description": "Long count of elements in the specified range."
          }
        },
        {
          "signature": "Long lrange(ValueStreamingChannel<V> channel, K key, long start, long stop)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of elements in the specified range."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<V>> lrange(K key, long start, long stop)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<V>>",
            "description": "Long count of elements in the specified range."
          }
        },
        {
          "signature": "RedisFuture<Long> lrange(ValueStreamingChannel<V> channel, K key, long start, long stop)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of elements in the specified range."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<V> lrange(K key, long start, long stop)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "Long count of elements in the specified range. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #lrange}."
          }
        },
        {
          "signature": "Mono<Long> lrange(ValueStreamingChannel<V> channel, K key, long start, long stop)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "the stop type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of elements in the specified range. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #lrange}."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "LRange(ctx context.Context, key string, start, stop int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "start",
              "type": "Any",
              "description": ""
            },
            {
              "name": "stop",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "LRANGE(key: RedisArgument, start: number, stop: number)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "start",
              "type": "number",
              "description": ""
            },
            {
              "name": "stop",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "lrange()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "lrange(key: K, start: isize, stop: isize)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "start",
              "type": "isize",
              "description": ""
            },
            {
              "name": "stop",
              "type": "isize",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "lrange(key: K, start: isize, stop: isize)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "start",
              "type": "isize",
              "description": ""
            },
            {
              "name": "stop",
              "type": "isize",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "ListRange(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "start",
              "type": "long",
              "description": "The start index of the list."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "The stop index of the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of elements in the specified range."
          }
        },
        {
          "signature": "ListRange(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "start",
              "type": "long",
              "description": "The start index of the list."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "The stop index of the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of elements in the specified range."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "ListRange(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "start",
              "type": "long",
              "description": "The start index of the list."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "The stop index of the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of elements in the specified range."
          }
        },
        {
          "signature": "ListRange(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the list."
            },
            {
              "name": "start",
              "type": "long",
              "description": "The start index of the list."
            },
            {
              "name": "stop",
              "type": "long",
              "description": "The stop index of the list."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of elements in the specified range."
          }
        }
      ],
      "php": [
        {
          "signature": "lrange(string $key, int $start, int $stop)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$start",
              "type": "int",
              "description": ""
            },
            {
              "name": "$stop",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "string[]",
            "description": ""
          }
        }
      ]
    }
  },
  "HSET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hset(, name: str,, key: Optional[str] = None,, value: Optional[str] = None,, mapping: Optional[dict] = None,, items: Optional[list] = None,)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "value",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "mapping",
              "type": "Optional[dict] = None",
              "description": ""
            },
            {
              "name": "items",
              "type": "Optional[list] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hset(final byte[] key, final byte[] field, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "field",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final byte[] key, final Map<byte[], byte[]> hash)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "hash",
              "type": "Map<byte[], byte[]>",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final String key, final String field, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final String key, final Map<String, String> hash)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "hash",
              "type": "Map<String, String>",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean hset(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "field",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "Long hset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> hset(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "field",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "RedisFuture<Long> hset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> hset(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "field",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "Mono<Long> hset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HSet(ctx context.Context, key string, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HSET(...[key, value, fieldValue]: SingleFieldArguments | MultipleFieldsArguments)",
          "params": [
            {
              "name": "...[key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "fieldValue]",
              "type": "SingleFieldArguments | MultipleFieldsArguments",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hset(key: K, field: F, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hset(key: K, field: F, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        }
      ],
      "php": [
        {
          "signature": "hset(string $key, string $field, string $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            },
            {
              "name": "$value",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HGET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hget(name: str, key: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Optional[str]], Optional[str]]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String hget(final String key, final String field)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V hget(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the value associated with {@code field}, or {@code null} when {@code field} is not present in the hash or {@code key} does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> hget(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the value associated with {@code field}, or {@code null} when {@code field} is not present in the hash or {@code key} does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> hget(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the value associated with {@code field}, or {@code null} when {@code field} is not present in the hash or {@code key} does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HGet(ctx context.Context, key, field string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "field",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HGET(key: RedisArgument, field: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "field",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hget()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hget(key: K, field: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hget(key: K, field: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "php": [
        {
          "signature": "hget(string $key, string $field)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HGETALL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hgetall(name: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[dict], dict]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "Map<String, String> hgetAll(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "Map<String, String>",
            "description": "All the fields and values contained into a hash."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Map<K, V> hgetall(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Map<K, V>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "Long hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Map<K, V>> hgetall(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Map<K, V>>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "RedisFuture<Long> hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> hgetall(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #hgetall}."
          }
        },
        {
          "signature": "Mono<Long> hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #hgetall}."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HGetAll(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*MapStringStringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HGETALL(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hgetall()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hgetall(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(std::collections::HashMap<String, String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hgetall(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(std::collections::HashMap<String, String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hgetall(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "SADD": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "sadd(name: KeyT, *values: FieldT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "*values",
              "type": "FieldT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long sadd(final byte[] key, final byte[]... members)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "members",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the new element was added, 0 if the element was already a member of the set"
          }
        },
        {
          "signature": "long sadd(final String key, final String... members)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "members",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the new element was added, 0 if the element was already a member of the set"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long sadd(K key, V... members)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "members",
              "type": "V...",
              "description": "the member type: value."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> sadd(K key, V... members)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "members",
              "type": "V...",
              "description": "the member type: value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> sadd(K key, V... members)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "members",
              "type": "V...",
              "description": "the member type: value."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "SAdd(ctx context.Context, key string, members ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "members",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SADD(key: RedisArgument, members: RedisVariadicArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "members",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "sadd()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "sadd()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "sadd()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "sadd()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "sadd(key: K, member: M)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "member",
              "type": "M",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "sadd(key: K, member: M)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "member",
              "type": "M",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "SetAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "SetAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        },
        {
          "signature": "SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "values",
              "type": "RedisValue[]",
              "description": "The values to add to the set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of elements that were added to the set, not including all the elements already present into the set."
          }
        }
      ],
      "php": [
        {
          "signature": "sadd(string $key, array $members)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$members",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "SMEMBERS": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "smembers(name: KeyT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Set], Set]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "Set<String> smembers(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "Set<String>",
            "description": "Multi bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Set<V> smembers(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Set<V>",
            "description": "Long count of members of the resulting set."
          }
        },
        {
          "signature": "Long smembers(ValueStreamingChannel<V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of members of the resulting set."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Set<V>> smembers(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Set<V>>",
            "description": "Long count of members of the resulting set."
          }
        },
        {
          "signature": "RedisFuture<Long> smembers(ValueStreamingChannel<V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of members of the resulting set."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<V> smembers(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "Long count of members of the resulting set. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #smembers}."
          }
        },
        {
          "signature": "Mono<Long> smembers(ValueStreamingChannel<V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of members of the resulting set. @deprecated since 6.0 in favor of consuming large results through the {@link org.reactivestreams.Publisher} returned by {@link #smembers}."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "SMembers(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SMEMBERS(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "smembers()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "smembers(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(HashSet<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "smembers(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(HashSet<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "SetMembers(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "All elements of the set."
          }
        },
        {
          "signature": "SetMembers(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "All elements of the set."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "SetMembers(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "All elements of the set."
          }
        },
        {
          "signature": "SetMembers(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the set."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "All elements of the set."
          }
        }
      ],
      "php": [
        {
          "signature": "smembers(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string[]",
            "description": ""
          }
        }
      ]
    }
  }
}