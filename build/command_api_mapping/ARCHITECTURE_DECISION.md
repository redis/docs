# Architecture Decision: MCP Server vs Direct Integration\n\n## The Problem\n\nWe need to extract method signatures and doc comments from 14 client libraries, then match them to Redis commands using AI. Multiple team members need to use this tool.\n\n## Key Constraint: API Key Management\n\n**Direct Integration (Node.js + Claude API):**\n- Requires Claude/OpenAI API key\n- Can't store in source repo (security risk)\n- Each team member needs their own key\n- Each run requires prompting for key or using environment variable\n- Friction for team members without API access\n\n**MCP Server Approach:**\n- Rust WASM parsing tools exposed via MCP\n- Claude (via Augment) handles AI matching\n- Team members use Augment (which they already have)\n- No API key management needed\n- Augment handles authentication\n\n## Why MCP Server is Better Here\n\n### 1. **Team Access**\n- All team members have Augment\n- Not all team members have Claude/OpenAI API keys\n- MCP server removes the API key bottleneck\n\n### 2. **Separation of Concerns**\n- **MCP Server (Rust WASM)**: Pure parsing/extraction logic\n  - Extract method signatures\n  - Extract doc comments\n  - Validate extracted data\n  - No AI, no API keys needed\n  - Reusable in other contexts\n\n- **Claude (via Augment)**: AI matching logic\n  - Analyze signatures and docs\n  - Match methods to Redis commands\n  - Validate matches\n  - Handle edge cases\n\n### 3. **Maintainability**\n- Parsing logic is stable and language-specific\n- AI logic can evolve without touching parsing code\n- MCP server can be versioned independently\n- Easy to test parsing in isolation\n\n### 4. **Reusability**\n- MCP server could be used for other documentation extraction tasks\n- Could be shared with other teams\n- Could be open-sourced\n\n## Proposed Architecture\n\n```\n┌─────────────────────────────────────────────────────────┐\n│ Augment Agent (Claude)                                  │\n│ - Orchestrates extraction workflow                      │\n│ - Calls MCP server tools for parsing                    │\n│ - Calls Claude API for method-to-command matching       │\n│ - Aggregates results into final JSON                    │\n└─────────────────────────────────────────────────────────┘\n                          ↓\n┌─────────────────────────────────────────────────────────┐\n│ MCP Server (Rust + WASM)                                │\n│ Tools:                                                  │\n│ - extract_python_signatures(file_path)                  │\n│ - extract_java_signatures(file_path)                    │\n│ - extract_go_signatures(file_path)                      │\n│ - extract_doc_comments(file_path, language)             │\n│ - validate_signature(signature, language)               │\n└─────────────────────────────────────────────────────────┘\n                          ↓\n┌─────────────────────────────────────────────────────────┐\n│ Client Library Source Code                              │\n│ (redis-py, node-redis, go-redis, etc.)                  │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Implementation Plan\n\n### Phase 1: Build MCP Server (Rust + WASM)\n\n1. **Setup**\n   - Create Rust project with `tree-sitter` dependency\n   - Add tree-sitter grammars for: Python, Java, Go, TypeScript, Rust, C#, PHP\n   - Create WASM bindings with `wasm-bindgen`\n\n2. **Parsing Tools**\n   - `extract_signatures(file_path, language)` → JSON array of signatures\n   - `extract_doc_comments(file_path, language)` → JSON map of method → doc comment\n   - `validate_signature(signature, language)` → boolean\n\n3. **Output Format**\n   ```json\n   {\n     \"method_name\": \"set\",\n     \"signature\": \"set(name: str, value: str, ...) -> bool | None\",\n     \"doc_comment\": \"Set the string value as value of the key...\",\n     \"parameters\": [\n       {\"name\": \"name\", \"type\": \"str\"},\n       {\"name\": \"value\", \"type\": \"str\"}\n     ],\n     \"return_type\": \"bool | None\"\n   }\n   ```\n\n### Phase 2: MCP Server Wrapper\n\n1. Create MCP server that exposes parsing tools\n2. Package as Node.js module (can call WASM from Node)\n3. Define MCP tool schemas\n\n### Phase 3: Augment Integration\n\n1. Configure MCP server in Augment\n2. Create Augment agent that:\n   - Calls MCP tools to extract from each client library\n   - Calls Claude API to match methods to commands\n   - Aggregates into final JSON\n   - Validates against schema\n\n## Why This Works Better\n\n| Aspect | Direct Integration | MCP Server |\n|--------|-------------------|------------|\n| API Key Management | Each user needs key | Augment handles it |\n| Team Access | Limited to API key holders | All Augment users |\n| Reusability | Tied to this project | Can be reused |\n| Maintenance | Mixed concerns | Clean separation |\n| Testing | Harder to test parsing | Easy to test tools |\n| Extensibility | Hard to add new languages | Easy to add parsers |\n\n## About API Keys (The Lighter Side)\n\nYou're right that API key management isn't as hard as it seems:\n- Environment variables work fine\n- `.env` files (with `.gitignore`) work\n- CI/CD secrets work\n\nBUT:\n- MCP server approach is still better because:\n  - Team members don't need to manage keys\n  - Augment already handles authentication\n  - Cleaner separation of concerns\n  - More reusable\n\n## Recommendation\n\n**Go with MCP Server approach:**\n1. Build Rust WASM parsing tools\n2. Wrap in MCP server\n3. Use Augment to orchestrate extraction and matching\n4. Team members use Augment (which they already have)\n5. No API key friction\n6. Reusable for future documentation extraction tasks\n\n## Next Steps\n\n1. Confirm MCP server approach\n2. Design MCP tool schemas\n3. Start building Rust WASM parsing library\n4. Create MCP server wrapper\n5. Prototype with one client library (redis-py)\n"
