{
  "APPEND": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "append(key: KeyT, value: EncodableT)",
          "params": [
            {
              "name": "key",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long append(final byte[] key, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The total length of the string after the append operation."
          }
        },
        {
          "signature": "long append(final String key, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The total length of the string after the append operation."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long append(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the length of the string after the append operation."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> append(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the length of the string after the append operation."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> append(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the length of the string after the append operation."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Append(ctx context.Context, key, value string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "value",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "APPEND(key: RedisArgument, value: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "append()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "append(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "append(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringAppend(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to append to the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string after the append operation."
          }
        },
        {
          "signature": "StringAppend(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to append to the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string after the append operation."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringAppend(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to append to the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string after the append operation."
          }
        },
        {
          "signature": "StringAppend(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to append to the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string after the append operation."
          }
        }
      ],
      "php": [
        {
          "signature": "append(string $key, $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "DECR": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "decrby(name: KeyT, amount: int = 1)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long decrBy(final byte[] key, final long decrement)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decr(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decrBy(final String key, final long decrement)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decr(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of key after the decrement."
          }
        },
        {
          "signature": "Long decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of key after the decrement."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of key after the decrement."
          }
        },
        {
          "signature": "RedisFuture<Long> decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of key after the decrement."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of key after the decrement."
          }
        },
        {
          "signature": "Mono<Long> decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of key after the decrement."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Decr(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        },
        {
          "signature": "DecrBy(ctx context.Context, key string, decrement int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "DECR(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "DECRBY(key: RedisArgument, decrement: number)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "decr(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "decrby()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "decr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "decr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        }
      ],
      "php": [
        {
          "signature": "decr(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        },
        {
          "signature": "decrby(string $key, int $decrement)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$decrement",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "DECRBY": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "decrby(name: KeyT, amount: int = 1)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long decrBy(final byte[] key, final long decrement)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decr(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decrBy(final String key, final long decrement)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        },
        {
          "signature": "long decr(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of key after the decrement."
          }
        },
        {
          "signature": "Long decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of key after the decrement."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of key after the decrement."
          }
        },
        {
          "signature": "RedisFuture<Long> decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of key after the decrement."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> decr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of key after the decrement."
          }
        },
        {
          "signature": "Mono<Long> decrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the decrement type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of key after the decrement."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Decr(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        },
        {
          "signature": "DecrBy(ctx context.Context, key string, decrement int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "DECR(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "DECRBY(key: RedisArgument, decrement: number)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "decrement",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "decr(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "decrby()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "decr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "decr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the decrement."
          }
        },
        {
          "signature": "StringDecrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the decrement."
          }
        }
      ],
      "php": [
        {
          "signature": "decr(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        },
        {
          "signature": "decrby(string $key, int $decrement)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$decrement",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "DELEX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "delex(, name: KeyT,, ifeq: Optional[Union[bytes, str]] = None,, ifne: Optional[Union[bytes, str]] = None,, ifdeq: Optional[str] = None,, ifdne: Optional[str] = None,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "ifeq",
              "type": "Optional[Union[bytes, str]] = None",
              "description": ""
            },
            {
              "name": "ifne",
              "type": "Optional[Union[bytes, str]] = None",
              "description": ""
            },
            {
              "name": "ifdeq",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "ifdne",
              "type": "Optional[str] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long delex(final byte[] key, final CompareCondition condition)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "condition",
              "type": "CompareCondition",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key"
          }
        },
        {
          "signature": "long delex(final String key, final CompareCondition condition)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "condition",
              "type": "CompareCondition",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long delex(K key, CompareCondition<V> compareCondition)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "compareCondition",
              "type": "CompareCondition<V>",
              "description": "the compare condition, must not be null."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the number of keys that were removed. @since 7.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> delex(K key, CompareCondition<V> compareCondition)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "compareCondition",
              "type": "CompareCondition<V>",
              "description": "the compare condition, must not be null."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the number of keys that were removed. @since 7.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> delex(K key, CompareCondition<V> compareCondition)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "compareCondition",
              "type": "CompareCondition<V>",
              "description": "the compare condition, must not be null."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the number of keys that were removed. @since 7.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "DelExArgs(ctx context.Context, key string, a DelExArgs)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "a",
              "type": "DelExArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringDelete(RedisKey key, ValueCondition when, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "when",
              "type": "ValueCondition",
              "description": "The condition to enforce."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": ""
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringDelete(RedisKey key, ValueCondition when, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "when",
              "type": "ValueCondition",
              "description": "The condition to enforce."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "delex(string $key, string $flag, $flagValue)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$flag",
              "type": "string",
              "description": ""
            },
            {
              "name": "$flagValue",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "DIGEST": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "digest(name: KeyT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[str, bytes, None]",
            "description": "- None if the key does not exist - (bulk string) the XXH3 digest of the value as a hex string"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String digest(String script)",
          "params": [
            {
              "name": "script",
              "type": "String",
              "description": "script content."
            }
          ],
          "returns": {
            "type": "String",
            "description": "the SHA1 value. @since 6.0"
          }
        },
        {
          "signature": "String digest(byte[] script)",
          "params": [
            {
              "name": "script",
              "type": "byte[]",
              "description": "script content."
            }
          ],
          "returns": {
            "type": "String",
            "description": "the SHA1 value. @since 6.0"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "String digest(String script)",
          "params": [
            {
              "name": "script",
              "type": "String",
              "description": "script content."
            }
          ],
          "returns": {
            "type": "String",
            "description": "the SHA1 value. @since 6.0"
          }
        },
        {
          "signature": "String digest(byte[] script)",
          "params": [
            {
              "name": "script",
              "type": "byte[]",
              "description": "script content."
            }
          ],
          "returns": {
            "type": "String",
            "description": "the SHA1 value. @since 6.0"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "String digest(String script)",
          "params": [
            {
              "name": "script",
              "type": "String",
              "description": "script content."
            }
          ],
          "returns": {
            "type": "String",
            "description": "the SHA1 value. @since 6.0"
          }
        },
        {
          "signature": "String digest(byte[] script)",
          "params": [
            {
              "name": "script",
              "type": "byte[]",
              "description": "script content."
            }
          ],
          "returns": {
            "type": "String",
            "description": "the SHA1 value. @since 6.0"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Digest(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*DigestCmd",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "digest(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "digest(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringDigest(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": ""
            }
          ],
          "returns": {
            "type": "ValueCondition?",
            "description": ""
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringDigest(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": ""
            }
          ],
          "returns": {
            "type": "ValueCondition?",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "digest(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string",
            "description": ""
          }
        }
      ]
    }
  },
  "GET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "get(fmt: str, offset: BitfieldOffsetT)",
          "params": [
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "get(name: KeyT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String get(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V get(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the value of key, or null when key does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> get(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the value of key, or null when key does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> get(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the value of key, or null when key does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Get(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "GET(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "get()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "get(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        },
        {
          "signature": "get(mut self, get: bool)",
          "params": [
            {
              "name": "mut self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "Self",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "get(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        },
        {
          "signature": "get(mut self, get: bool)",
          "params": [
            {
              "name": "mut self",
              "type": "Any",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "Self",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys of the strings."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        },
        {
          "signature": "StringGet(key, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys of the strings."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys of the strings."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        },
        {
          "signature": "StringGet(key, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        },
        {
          "signature": "StringGet(RedisKey[] keys, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "keys",
              "type": "RedisKey[]",
              "description": "The keys of the strings."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the strings with RedisValue.Null for keys do not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "get(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "GETDEL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "getdel(name: KeyT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String getDel(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "The value of key"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V getdel(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the value of key, or null when key does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> getdel(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the value of key, or null when key does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> getdel(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the value of key, or null when key does not exist. @since 6.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "GetDel(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "GETDEL(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "getdel()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "get_del(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "get_del(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringGetDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        },
        {
          "signature": "StringGetDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringGetDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        },
        {
          "signature": "StringGetDelete(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "getdel(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string",
            "description": ""
          }
        }
      ]
    }
  },
  "GETEX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "getex(, name: KeyT,, ex: Optional[ExpiryT] = None,, px: Optional[ExpiryT] = None,, exat: Optional[AbsExpiryT] = None,, pxat: Optional[AbsExpiryT] = None,, persist: bool = False,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "ex",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "px",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "exat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "pxat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "persist",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String getEx(String key, GetExParams params)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "params",
              "type": "GetExParams",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "The value of key"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V getex(K key, GetExArgs args)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "args",
              "type": "GetExArgs",
              "description": "the arguments for GETEX."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the value of key, or null when key does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> getex(K key, GetExArgs args)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "args",
              "type": "GetExArgs",
              "description": "the arguments for GETEX."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the value of key, or null when key does not exist. @since 6.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> getex(K key, GetExArgs args)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "args",
              "type": "GetExArgs",
              "description": "the arguments for GETEX."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the value of key, or null when key does not exist. @since 6.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "GetEx(ctx context.Context, key string, expiration time.Duration)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "expiration",
              "type": "time.Duration",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "GETEX(key: RedisArgument, options: GetExOptions)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "options",
              "type": "GetExOptions",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "getex()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "getex()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "getex()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "getex()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "getex()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "get_ex(key: K, expire_at: Expiry)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "expire_at",
              "type": "Expiry",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "get_ex(key: K, expire_at: Expiry)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "expire_at",
              "type": "Expiry",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringGetSetExpiry(RedisKey key, TimeSpan? expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to expire at. DateTime.MaxValue will remove expiry."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        },
        {
          "signature": "StringGetSetExpiry(RedisKey key, DateTime expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date and time to expire at. DateTime.MaxValue will remove expiry."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        },
        {
          "signature": "StringGetSetExpiry(RedisKey key, TimeSpan? expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to expire at. DateTime.MaxValue will remove expiry."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        },
        {
          "signature": "StringGetSetExpiry(RedisKey key, DateTime expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date and time to expire at. DateTime.MaxValue will remove expiry."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringGetSetExpiry(RedisKey key, TimeSpan? expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to expire at. DateTime.MaxValue will remove expiry."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        },
        {
          "signature": "StringGetSetExpiry(RedisKey key, DateTime expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date and time to expire at. DateTime.MaxValue will remove expiry."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        },
        {
          "signature": "StringGetSetExpiry(RedisKey key, TimeSpan? expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to expire at. DateTime.MaxValue will remove expiry."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        },
        {
          "signature": "StringGetSetExpiry(RedisKey key, DateTime expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date and time to expire at. DateTime.MaxValue will remove expiry."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The value of key, or RedisValue.Null when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "getex(string $key, $modifier = '', $value = false)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$modifier = ''",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$value = false",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int|null",
            "description": ""
          }
        }
      ]
    }
  },
  "GETRANGE": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "getrange(key: KeyT, start: int, end: int)",
          "params": [
            {
              "name": "key",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "start",
              "type": "int",
              "description": ""
            },
            {
              "name": "end",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String getrange(final String key, final long startOffset, final long endOffset)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "startOffset",
              "type": "long",
              "description": ""
            },
            {
              "name": "endOffset",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V getrange(K key, long start, long end)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "end",
              "type": "long",
              "description": "the end type: long."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> getrange(K key, long start, long end)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "end",
              "type": "long",
              "description": "the end type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> getrange(K key, long start, long end)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "end",
              "type": "long",
              "description": "the end type: long."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "GetRange(ctx context.Context, key string, start, end int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "start",
              "type": "Any",
              "description": ""
            },
            {
              "name": "end",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "GETRANGE(key: RedisArgument, start: number, end: number)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "start",
              "type": "number",
              "description": ""
            },
            {
              "name": "end",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "getrange()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "getrange(key: K, from: isize, to: isize)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "from",
              "type": "isize",
              "description": ""
            },
            {
              "name": "to",
              "type": "isize",
              "description": ""
            }
          ],
          "returns": {
            "type": "(String)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "getrange(key: K, from: isize, to: isize)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "from",
              "type": "isize",
              "description": ""
            },
            {
              "name": "to",
              "type": "isize",
              "description": ""
            }
          ],
          "returns": {
            "type": "(String)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringGetRange(RedisKey key, long start, long end, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "start",
              "type": "long",
              "description": "The start index of the substring to get."
            },
            {
              "name": "end",
              "type": "long",
              "description": "The end index of the substring to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The substring of the string value stored at key."
          }
        },
        {
          "signature": "StringGetRange(RedisKey key, long start, long end, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "start",
              "type": "long",
              "description": "The start index of the substring to get."
            },
            {
              "name": "end",
              "type": "long",
              "description": "The end index of the substring to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The substring of the string value stored at key."
          }
        },
        {
          "signature": "GetRange(double value, Exclude exclude, bool isStart)",
          "params": [
            {
              "name": "value",
              "type": "double",
              "description": ""
            },
            {
              "name": "exclude",
              "type": "Exclude",
              "description": ""
            },
            {
              "name": "isStart",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": ""
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringGetRange(RedisKey key, long start, long end, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "start",
              "type": "long",
              "description": "The start index of the substring to get."
            },
            {
              "name": "end",
              "type": "long",
              "description": "The end index of the substring to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The substring of the string value stored at key."
          }
        },
        {
          "signature": "StringGetRange(RedisKey key, long start, long end, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "start",
              "type": "long",
              "description": "The start index of the substring to get."
            },
            {
              "name": "end",
              "type": "long",
              "description": "The end index of the substring to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The substring of the string value stored at key."
          }
        },
        {
          "signature": "GetRange(double value, Exclude exclude, bool isStart)",
          "params": [
            {
              "name": "value",
              "type": "double",
              "description": ""
            },
            {
              "name": "exclude",
              "type": "Exclude",
              "description": ""
            },
            {
              "name": "isStart",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "getrange(string $key, $start, $end)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$start",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$end",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string",
            "description": ""
          }
        }
      ]
    }
  },
  "GETSET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "getset(name: KeyT, value: EncodableT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String getSet(final String key, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply @deprecated Use Jedis#setGet(java.lang.String, java.lang.String)."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V getset(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the old value stored at key, or null when key did not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> getset(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the old value stored at key, or null when key did not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> getset(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the old value stored at key, or null when key did not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "GetSet(ctx context.Context, key string, value interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "GETSET(key: RedisArgument, value: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "getset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "getset(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "getset(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringGetSet(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to replace the existing value with."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The old value stored at key, or RedisValue.Null when key did not exist."
          }
        },
        {
          "signature": "StringGetSet(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to replace the existing value with."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The old value stored at key, or RedisValue.Null when key did not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringGetSet(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to replace the existing value with."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The old value stored at key, or RedisValue.Null when key did not exist."
          }
        },
        {
          "signature": "StringGetSet(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to replace the existing value with."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The old value stored at key, or RedisValue.Null when key did not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "getset(string $key, $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "INCR": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "incrby(, fmt: str,, offset: BitfieldOffsetT,, increment: int,, overflow: Optional[str] = None,)",
          "params": [
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            },
            {
              "name": "increment",
              "type": "int",
              "description": ""
            },
            {
              "name": "overflow",
              "type": "Optional[str] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "incrby(name: KeyT, amount: int = 1)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long incrBy(final byte[] key, final long increment)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "increment",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incr(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incrBy(final String key, final long increment)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "increment",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incr(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of key after the increment."
          }
        },
        {
          "signature": "Long incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of key after the increment."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of key after the increment."
          }
        },
        {
          "signature": "RedisFuture<Long> incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of key after the increment."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of key after the increment."
          }
        },
        {
          "signature": "Mono<Long> incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of key after the increment."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Incr(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        },
        {
          "signature": "IncrBy(ctx context.Context, key string, value int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "INCR(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "INCRBY(key: RedisArgument, increment: number)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "increment",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "incr(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "incrby()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "incr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "incr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "php": [
        {
          "signature": "incr(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        },
        {
          "signature": "incrby(string $key, int $increment)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$increment",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "INCRBY": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "incrby(, fmt: str,, offset: BitfieldOffsetT,, increment: int,, overflow: Optional[str] = None,)",
          "params": [
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            },
            {
              "name": "increment",
              "type": "int",
              "description": ""
            },
            {
              "name": "overflow",
              "type": "Optional[str] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "incrby(name: KeyT, amount: int = 1)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long incrBy(final byte[] key, final long increment)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "increment",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incr(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incrBy(final String key, final long increment)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "increment",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long incr(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of key after the increment."
          }
        },
        {
          "signature": "Long incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value of key after the increment."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of key after the increment."
          }
        },
        {
          "signature": "RedisFuture<Long> incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value of key after the increment."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> incr(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of key after the increment."
          }
        },
        {
          "signature": "Mono<Long> incrby(K key, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value of key after the increment."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Incr(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        },
        {
          "signature": "IncrBy(ctx context.Context, key string, value int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "INCR(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "INCRBY(key: RedisArgument, increment: number)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "increment",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "incr(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        },
        {
          "signature": "incrby()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "incr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "incr(key: K, delta: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "delta",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(isize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "php": [
        {
          "signature": "incr(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        },
        {
          "signature": "incrby(string $key, int $increment)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$increment",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "INCRBYFLOAT": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "incrbyfloat(name: KeyT, amount: float = 1.0)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "amount",
              "type": "float = 1.0",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "double incrByFloat(final byte[] key, final double increment)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "increment",
              "type": "double",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "double incrByFloat(final String key, final double increment)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "increment",
              "type": "double",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Double incrbyfloat(K key, double amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "double",
              "description": "the increment type: double."
            }
          ],
          "returns": {
            "type": "Double",
            "description": "Double bulk-string-reply the value of key after the increment."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Double> incrbyfloat(K key, double amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "double",
              "description": "the increment type: double."
            }
          ],
          "returns": {
            "type": "RedisFuture<Double>",
            "description": "Double bulk-string-reply the value of key after the increment."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Double> incrbyfloat(K key, double amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "amount",
              "type": "double",
              "description": "the increment type: double."
            }
          ],
          "returns": {
            "type": "Mono<Double>",
            "description": "Double bulk-string-reply the value of key after the increment."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "IncrByFloat(ctx context.Context, key string, value float64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "float64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*FloatCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "INCRBYFLOAT(key: RedisArgument, increment: number)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "increment",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "incrbyfloat()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(key, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the string."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value of key after the increment."
          }
        },
        {
          "signature": "StringIncrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by (defaults to 1)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment."
          }
        }
      ],
      "php": [
        {
          "signature": "incrbyfloat(string $key, int|float $increment)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$increment",
              "type": "int|float",
              "description": ""
            }
          ],
          "returns": {
            "type": "string",
            "description": ""
          }
        }
      ]
    }
  },
  "LCS": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "stralgo(, algo: Literal[\"LCS\"],, value1: KeyT,, value2: KeyT,, specific_argument: Union[Literal[\"strings\"], Literal[\"keys\"]] = \"strings\",, len: bool = False,, idx: bool = False,, minmatchlen: Optional[int] = None,, withmatchlen: bool = False,, **kwargs,)",
          "params": [
            {
              "name": "algo",
              "type": "Literal[\"LCS\"]",
              "description": ""
            },
            {
              "name": "value1",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "value2",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "specific_argument",
              "type": "Union[Literal[\"strings\"], Literal[\"keys\"]] = \"strings\"",
              "description": ""
            },
            {
              "name": "len",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "idx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "minmatchlen",
              "type": "Optional[int] = None",
              "description": ""
            },
            {
              "name": "withmatchlen",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "**kwargs",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        },
        {
          "signature": "lcs(, key1: str,, key2: str,, len: Optional[bool] = False,, idx: Optional[bool] = False,, minmatchlen: Optional[int] = 0,, withmatchlen: Optional[bool] = False,)",
          "params": [
            {
              "name": "key1",
              "type": "str",
              "description": ""
            },
            {
              "name": "key2",
              "type": "str",
              "description": ""
            },
            {
              "name": "len",
              "type": "Optional[bool] = False",
              "description": ""
            },
            {
              "name": "idx",
              "type": "Optional[bool] = False",
              "description": ""
            },
            {
              "name": "minmatchlen",
              "type": "Optional[int] = 0",
              "description": ""
            },
            {
              "name": "withmatchlen",
              "type": "Optional[bool] = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[str, int, list]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "LCSMatchResult lcs(final byte[] keyA, final byte[] keyB, final LCSParams params)",
          "params": [
            {
              "name": "keyA",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "keyB",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "params",
              "type": "LCSParams",
              "description": ""
            }
          ],
          "returns": {
            "type": "LCSMatchResult",
            "description": "According to LCSParams to decide to return content to fill LCSMatchResult."
          }
        },
        {
          "signature": "LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params)",
          "params": [
            {
              "name": "keyA",
              "type": "String",
              "description": ""
            },
            {
              "name": "keyB",
              "type": "String",
              "description": ""
            },
            {
              "name": "params",
              "type": "LCSParams",
              "description": ""
            }
          ],
          "returns": {
            "type": "LCSMatchResult",
            "description": "According to LCSParams to decide to return content to fill LCSMatchResult."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "StringMatchResult lcs(LcsArgs lcsArgs)",
          "params": [
            {
              "name": "lcsArgs",
              "type": "LcsArgs",
              "description": "command arguments supplied by the LcsArgs."
            }
          ],
          "returns": {
            "type": "StringMatchResult",
            "description": "StringMatchResult @see <a href=\"https://redis.io/commands/lcs\">LCS command refference</a> @since 6.6"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<StringMatchResult> lcs(LcsArgs lcsArgs)",
          "params": [
            {
              "name": "lcsArgs",
              "type": "LcsArgs",
              "description": "command arguments supplied by the LcsArgs."
            }
          ],
          "returns": {
            "type": "RedisFuture<StringMatchResult>",
            "description": "StringMatchResult @see <a href=\"https://redis.io/commands/lcs\">LCS command refference</a> @since 6.6"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<StringMatchResult> lcs(LcsArgs lcsArgs)",
          "params": [
            {
              "name": "lcsArgs",
              "type": "LcsArgs",
              "description": "command arguments supplied by the LcsArgs."
            }
          ],
          "returns": {
            "type": "Mono<StringMatchResult>",
            "description": "StringMatchResult @see <a href=\"https://redis.io/commands/lcs\">LCS command refference</a> @since 6.6"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "LCS(ctx context.Context, q *LCSQuery)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "q",
              "type": "*LCSQuery",
              "description": ""
            }
          ],
          "returns": {
            "type": "*LCSCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "LCS()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "lcs()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "lcs()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "lcs()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "lcs()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "lcs()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "lcs(string $key1, string $key2, bool $len = false, bool $idx = false, int $minMatchLen = 0, bool $withMatchLen = false)",
          "params": [
            {
              "name": "$key1",
              "type": "string",
              "description": ""
            },
            {
              "name": "$key2",
              "type": "string",
              "description": ""
            },
            {
              "name": "bool $len = false",
              "type": "Any",
              "description": ""
            },
            {
              "name": "bool $idx = false",
              "type": "Any",
              "description": ""
            },
            {
              "name": "int $minMatchLen = 0",
              "type": "Any",
              "description": ""
            },
            {
              "name": "bool $withMatchLen = false",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "mixed",
            "description": ""
          }
        }
      ]
    }
  },
  "MGET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "mget(keys: KeysT, *args: EncodableT)",
          "params": [
            {
              "name": "keys",
              "type": "KeysT",
              "description": ""
            },
            {
              "name": "*args",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> mget(final String... keys)",
          "params": [
            {
              "name": "keys",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Multi bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<KeyValue<K, V>> mget(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "List<KeyValue<K, V>>",
            "description": "Long array-reply list of values at the specified keys."
          }
        },
        {
          "signature": "Long mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long array-reply list of values at the specified keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<KeyValue<K, V>>> mget(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<KeyValue<K, V>>>",
            "description": "Long array-reply list of values at the specified keys."
          }
        },
        {
          "signature": "RedisFuture<Long> mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long array-reply list of values at the specified keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> mget(K... keys)",
          "params": [
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long array-reply list of values at the specified keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #mget."
          }
        },
        {
          "signature": "Mono<Long> mget(KeyValueStreamingChannel<K, V> channel, K... keys)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "keys",
              "type": "K...",
              "description": "the keys."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long array-reply list of values at the specified keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #mget."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "MGet(ctx context.Context, keys ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "keys",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*SliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "MGET(keys: Array<RedisArgument>)",
          "params": [
            {
              "name": "keys",
              "type": "Array<RedisArgument>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "mget()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mget()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mget(...args: [...keys: RedisKey[]])",
          "params": [
            {
              "name": "...args",
              "type": "[...keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<(string | null)[], Context>",
            "description": ""
          }
        },
        {
          "signature": "mget(...args: [keys: RedisKey[]])",
          "params": [
            {
              "name": "...args",
              "type": "[keys",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<(string | null)[], Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "mget(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<Option<String>>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "mget(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<Option<String>>)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "mget(string[]|string $keyOrKeys, string ...$keys = null)",
          "params": [
            {
              "name": "$keyOrKeys",
              "type": "string[]|string",
              "description": ""
            },
            {
              "name": "string ...$keys = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "MSET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "mset(mapping: Mapping[AnyKeyT, EncodableT])",
          "params": [
            {
              "name": "mapping",
              "type": "Mapping[AnyKeyT, EncodableT]",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String mset(final byte[]... keysvalues)",
          "params": [
            {
              "name": "keysvalues",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK"
          }
        },
        {
          "signature": "String mset(final String... keysvalues)",
          "params": [
            {
              "name": "keysvalues",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String mset(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply always OK since MSET can't fail."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> mset(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply always OK since MSET can't fail."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> mset(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply always OK since MSET can't fail."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "MSet(ctx context.Context, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StatusCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "MSET(toSet: MSetArguments)",
          "params": [
            {
              "name": "toSet",
              "type": "MSetArguments",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "mset(object: object, callback?: Callback<\"OK\">)",
          "params": [
            {
              "name": "object",
              "type": "object",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<\"OK\">",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<\"OK\", Context>",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "mset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "mset(items: &'a [(K, V)])",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K, V)]",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "mset(items: &'a [(K, V)])",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K, V)]",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "mset(array $dictionary)",
          "params": [
            {
              "name": "$dictionary",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "mixed",
            "description": ""
          }
        }
      ]
    }
  },
  "MSETEX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "msetex(, mapping: Mapping[AnyKeyT, EncodableT],, data_persist_option: Optional[DataPersistOptions] = None,, ex: Optional[ExpiryT] = None,, px: Optional[ExpiryT] = None,, exat: Optional[AbsExpiryT] = None,, pxat: Optional[AbsExpiryT] = None,, keepttl: bool = False,)",
          "params": [
            {
              "name": "mapping",
              "type": "Mapping[AnyKeyT, EncodableT]",
              "description": ""
            },
            {
              "name": "data_persist_option",
              "type": "Optional[DataPersistOptions] = None",
              "description": ""
            },
            {
              "name": "ex",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "px",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "exat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "pxat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "keepttl",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "boolean msetex(final MSetExParams params, final byte[]... keysvalues)",
          "params": [
            {
              "name": "params",
              "type": "MSetExParams",
              "description": ""
            },
            {
              "name": "keysvalues",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "boolean",
            "description": "1 if the all the keys were set, 0 if no key was set (at least one key already existed)"
          }
        },
        {
          "signature": "boolean msetex(final MSetExParams params, final String... keysvalues)",
          "params": [
            {
              "name": "params",
              "type": "MSetExParams",
              "description": ""
            },
            {
              "name": "keysvalues",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "boolean",
            "description": "1 if the all the keys were set, 0 if no key was set (at least one key already existed)"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean msetex(Map<K, V> map, MSetExArgs args)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map of keys and values."
            },
            {
              "name": "args",
              "type": "MSetExArgs",
              "description": "the MSetExArgs specifying NX/XX and expiration."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean from integer-reply: 1 if all keys were set, 0 otherwise. @since 7.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> msetex(Map<K, V> map, MSetExArgs args)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map of keys and values."
            },
            {
              "name": "args",
              "type": "MSetExArgs",
              "description": "the MSetExArgs specifying NX/XX and expiration."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean from integer-reply: 1 if all keys were set, 0 otherwise. @since 7.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> msetex(Map<K, V> map, MSetExArgs args)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map of keys and values."
            },
            {
              "name": "args",
              "type": "MSetExArgs",
              "description": "the MSetExArgs specifying NX/XX and expiration."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean from integer-reply: 1 if all keys were set, 0 otherwise. @since 7.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "MSetEX(ctx context.Context, args MSetEXArgs, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "args",
              "type": "MSetEXArgs",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "mset_ex(items: &'a [(K, V)], options: MSetOptions)",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K, V)]",
              "description": ""
            },
            {
              "name": "options",
              "type": "MSetOptions",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "mset_ex(items: &'a [(K, V)], options: MSetOptions)",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K, V)]",
              "description": ""
            },
            {
              "name": "options",
              "type": "MSetOptions",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "msetex(array $dictionary, ?string $existModifier = null, ?string $expireResolution = null, ?int $expireTTL = null)",
          "params": [
            {
              "name": "$dictionary",
              "type": "array",
              "description": ""
            },
            {
              "name": "?string $existModifier = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "?string $expireResolution = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "?int $expireTTL = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "MSETNX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "msetnx(mapping: Mapping[AnyKeyT, EncodableT])",
          "params": [
            {
              "name": "mapping",
              "type": "Mapping[AnyKeyT, EncodableT]",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long msetnx(final byte[]... keysvalues)",
          "params": [
            {
              "name": "keysvalues",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the all the keys were set, 0 if no key was set (at least one key already existed)"
          }
        },
        {
          "signature": "long msetnx(final String... keysvalues)",
          "params": [
            {
              "name": "keysvalues",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the all the keys were set, 0 if no key was set (at least one key already existed)"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean msetnx(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: 1 if the all the keys were set. 0 if no key was set (at least one key already existed)."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> msetnx(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: 1 if the all the keys were set. 0 if no key was set (at least one key already existed)."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> msetnx(Map<K, V> map)",
          "params": [
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the map."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: 1 if the all the keys were set. 0 if no key was set (at least one key already existed)."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "MSetNX(ctx context.Context, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*BoolCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "MSETNX(toSet: MSetArguments)",
          "params": [
            {
              "name": "toSet",
              "type": "MSetArguments",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "msetnx(object: object, callback?: Callback<\"OK\">)",
          "params": [
            {
              "name": "object",
              "type": "object",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<\"OK\">",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<\"OK\", Context>",
            "description": ""
          }
        },
        {
          "signature": "msetnx()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "msetnx()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "msetnx()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "mset_nx(items: &'a [(K, V)])",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K, V)]",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "mset_nx(items: &'a [(K, V)])",
          "params": [
            {
              "name": "items",
              "type": "&'a [(K, V)]",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "msetnx(array $dictionary)",
          "params": [
            {
              "name": "$dictionary",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "PSETEX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "psetex(name: KeyT, time_ms: ExpiryT, value: EncodableT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "time_ms",
              "type": "ExpiryT",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String psetex(final byte[] key, final long milliseconds, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK @deprecated Use Jedis#set(String, String, redis.clients.jedis.params.SetParams) with redis.clients.jedis.params.SetParams#px(long). Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 2.6.12."
          }
        },
        {
          "signature": "String psetex(final String key, final long milliseconds, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK @deprecated Use Jedis#set(String, String, redis.clients.jedis.params.SetParams) with redis.clients.jedis.params.SetParams#px(long). Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 2.6.12."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String psetex(K key, long milliseconds, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> psetex(K key, long milliseconds, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> psetex(K key, long milliseconds, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply."
          }
        }
      ],
      "node_redis": [
        {
          "signature": "PSETEX(key: RedisArgument, ms: number, value: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "ms",
              "type": "number",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "psetex()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "pset_ex(key: K, value: V, milliseconds: u64)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "u64",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "pset_ex(key: K, value: V, milliseconds: u64)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "u64",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "psetex(string $key, $milliseconds, $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$milliseconds",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Status",
            "description": ""
          }
        }
      ]
    }
  },
  "SET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "set(fmt: str, offset: BitfieldOffsetT, value: int)",
          "params": [
            {
              "name": "fmt",
              "type": "str",
              "description": ""
            },
            {
              "name": "offset",
              "type": "BitfieldOffsetT",
              "description": ""
            },
            {
              "name": "value",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set(, name: KeyT,, value: EncodableT,, ex: Optional[ExpiryT] = None,, px: Optional[ExpiryT] = None,, nx: bool = False,, xx: bool = False,, keepttl: bool = False,, get: bool = False,, exat: Optional[AbsExpiryT] = None,, pxat: Optional[AbsExpiryT] = None,, ifeq: Optional[Union[bytes, str]] = None,, ifne: Optional[Union[bytes, str]] = None,, ifdeq: Optional[str] = None,, ifdne: Optional[str] = None,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            },
            {
              "name": "ex",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "px",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "keepttl",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "get",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "exat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "pxat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "ifeq",
              "type": "Optional[Union[bytes, str]] = None",
              "description": ""
            },
            {
              "name": "ifne",
              "type": "Optional[Union[bytes, str]] = None",
              "description": ""
            },
            {
              "name": "ifdeq",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "ifdne",
              "type": "Optional[str] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String set(final byte[] key, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply OK if SET was executed correctly, or null if the SET operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final byte[] key, final byte[] value, final SetParams params)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "params",
              "type": "SetParams",
              "description": "key if it already exists. EX|PX, expire time units: EX = seconds; PX = milliseconds"
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply OK if SET was executed correctly, or null if the SET operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final String key, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply OK if SET was executed correctly, or null if the SET operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        },
        {
          "signature": "String set(final String key, final String value, final SetParams params)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            },
            {
              "name": "params",
              "type": "SetParams",
              "description": "key if it already exists. EX|PX, expire time units: EX = seconds; PX = milliseconds"
            }
          ],
          "returns": {
            "type": "String",
            "description": "simple-string-reply OK if SET was executed correctly, or null if the SET operation was not performed because the user specified the NX or XX option but the condition was not met."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String set(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply OK if SET was executed correctly."
          }
        },
        {
          "signature": "String set(K key, V value, SetArgs setArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            },
            {
              "name": "setArgs",
              "type": "SetArgs",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply OK if SET was executed correctly."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> set(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply OK if SET was executed correctly."
          }
        },
        {
          "signature": "RedisFuture<String> set(K key, V value, SetArgs setArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            },
            {
              "name": "setArgs",
              "type": "SetArgs",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply OK if SET was executed correctly."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> set(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply OK if SET was executed correctly."
          }
        },
        {
          "signature": "Mono<String> set(K key, V value, SetArgs setArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            },
            {
              "name": "setArgs",
              "type": "SetArgs",
              "description": "the setArgs."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply OK if SET was executed correctly."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "Set(ctx context.Context, key string, value interface{}, expiration time.Duration)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "interface{}",
              "description": ""
            },
            {
              "name": "expiration",
              "type": "time.Duration",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StatusCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SET(key: RedisArgument, value: RedisArgument | number, options?: SetOptions)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument | number",
              "description": ""
            },
            {
              "name": "options?",
              "type": "SetOptions",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "set()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "set(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "set(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, bool keepTtl, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "keepTtl",
              "type": "bool",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, Expiration expiry = default, ValueCondition when = default, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "Expiration",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "ValueCondition",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(KeyValuePair<RedisKey, RedisValue>[] values, When when, CommandFlags flags)",
          "params": [
            {
              "name": "values",
              "type": "KeyValuePair<RedisKey, RedisValue>[]",
              "description": "The keys and values to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, When when, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, TimeSpan? expiry, bool keepTtl, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The expiry to set."
            },
            {
              "name": "keepTtl",
              "type": "bool",
              "description": ""
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(RedisKey key, RedisValue value, Expiration expiry = default, ValueCondition when = default, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "Expiration",
              "description": "The expiry to set."
            },
            {
              "name": "when",
              "type": "ValueCondition",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        },
        {
          "signature": "StringSet(KeyValuePair<RedisKey, RedisValue>[] values, When when, CommandFlags flags)",
          "params": [
            {
              "name": "values",
              "type": "KeyValuePair<RedisKey, RedisValue>[]",
              "description": "The keys and values to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which condition to set the value under (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the keys were set, <see langword=\"false\"/> otherwise."
          }
        }
      ],
      "php": [
        {
          "signature": "set(string $key, $value, $expireResolution = null, $expireTTL = null, $flag = null, $flagValue = null)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$expireResolution = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$expireTTL = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$flag = null",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$flagValue = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Status|null",
            "description": ""
          }
        }
      ]
    }
  },
  "SETEX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "setex(name: KeyT, time: ExpiryT, value: EncodableT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "time",
              "type": "ExpiryT",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String setex(final byte[] key, final long seconds, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK @deprecated Use Jedis#set(String, String, redis.clients.jedis.params.SetParams) with redis.clients.jedis.params.SetParams#ex(long). Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 2.6.12."
          }
        },
        {
          "signature": "String setex(final String key, final long seconds, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "OK @deprecated Use Jedis#set(String, String, redis.clients.jedis.params.SetParams) with redis.clients.jedis.params.SetParams#ex(long). Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 2.6.12."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String setex(K key, long seconds, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> setex(K key, long seconds, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> setex(K key, long seconds, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the seconds type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "SetEx(ctx context.Context, key string, value interface{}, expiration time.Duration)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "interface{}",
              "description": ""
            },
            {
              "name": "expiration",
              "type": "time.Duration",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StatusCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SETEX(key: RedisArgument, seconds: number, value: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "number",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "setex()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "set_ex(key: K, value: V, seconds: u64)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "u64",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "set_ex(key: K, value: V, seconds: u64)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "u64",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "setex(string $key, $seconds, $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$seconds",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "Status",
            "description": ""
          }
        }
      ]
    }
  },
  "SETNX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "setnx(name: KeyT, value: EncodableT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long setnx(final byte[] key, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the key was set, 0 if the key was not set @deprecated Use Jedis#set(String, String, redis.clients.jedis.params.SetParams) with redis.clients.jedis.params.SetParams#nx(). Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 2.6.12."
          }
        },
        {
          "signature": "long setnx(final String key, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "1 if the key was set, 0 if the key was not set @deprecated Use Jedis#set(String, String, redis.clients.jedis.params.SetParams) with redis.clients.jedis.params.SetParams#nx(). Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 2.6.12."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean setnx(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: 1 if the key was set 0 if the key was not set."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> setnx(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: 1 if the key was set 0 if the key was not set."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> setnx(K key, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: 1 if the key was set 0 if the key was not set."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "interface{}",
              "description": ""
            },
            {
              "name": "expiration",
              "type": "time.Duration",
              "description": ""
            }
          ],
          "returns": {
            "type": "*BoolCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SETNX(key: RedisArgument, value: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "setnx()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "set_nx(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "set_nx(key: K, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "setnx(string $key, $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "SETRANGE": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "setrange(name: KeyT, offset: int, value: EncodableT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "offset",
              "type": "int",
              "description": ""
            },
            {
              "name": "value",
              "type": "EncodableT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long setrange(final byte[] key, final long offset, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "offset",
              "type": "long",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": ""
          }
        },
        {
          "signature": "long setrange(final String key, final long offset, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "offset",
              "type": "long",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long setrange(K key, long offset, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "offset",
              "type": "long",
              "description": "the offset type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the length of the string after it was modified by the command."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> setrange(K key, long offset, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "offset",
              "type": "long",
              "description": "the offset type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the length of the string after it was modified by the command."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> setrange(K key, long offset, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "offset",
              "type": "long",
              "description": "the offset type: long."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the length of the string after it was modified by the command."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "SetRange(ctx context.Context, key string, offset int64, value string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "offset",
              "type": "int64",
              "description": ""
            },
            {
              "name": "value",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "SETRANGE(key: RedisArgument, offset: number, value: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "offset",
              "type": "number",
              "description": ""
            },
            {
              "name": "value",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "setrange()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "setrange(key: K, offset: isize, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "offset",
              "type": "isize",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "setrange(key: K, offset: isize, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "offset",
              "type": "isize",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "offset",
              "type": "long",
              "description": "The offset in the string to overwrite."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to overwrite with."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The length of the string after it was modified by the command."
          }
        },
        {
          "signature": "StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "offset",
              "type": "long",
              "description": "The offset in the string to overwrite."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to overwrite with."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The length of the string after it was modified by the command."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "offset",
              "type": "long",
              "description": "The offset in the string to overwrite."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to overwrite with."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The length of the string after it was modified by the command."
          }
        },
        {
          "signature": "StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "offset",
              "type": "long",
              "description": "The offset in the string to overwrite."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to overwrite with."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The length of the string after it was modified by the command."
          }
        }
      ],
      "php": [
        {
          "signature": "setrange(string $key, $offset, $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$offset",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$value",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "STRLEN": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "strlen(name: KeyT)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long strlen(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": ""
          }
        },
        {
          "signature": "long strlen(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long strlen(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the length of the string at key, or 0 when key does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> strlen(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the length of the string at key, or 0 when key does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> strlen(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the length of the string at key, or 0 when key does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "StrLen(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "STRLEN(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "strlen(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "strlen(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "strlen(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field containing the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at field, or 0 when key does not exist."
          }
        },
        {
          "signature": "StringLength(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at key, or 0 when key does not exist."
          }
        },
        {
          "signature": "HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field containing the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at field, or 0 when key does not exist."
          }
        },
        {
          "signature": "StringLength(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at key, or 0 when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field containing the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at field, or 0 when key does not exist."
          }
        },
        {
          "signature": "StringLength(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at key, or 0 when key does not exist."
          }
        },
        {
          "signature": "HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field containing the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at field, or 0 when key does not exist."
          }
        },
        {
          "signature": "StringLength(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at key, or 0 when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "strlen(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "SUBSTR": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "getrange(key: KeyT, start: int, end: int)",
          "params": [
            {
              "name": "key",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "start",
              "type": "int",
              "description": ""
            },
            {
              "name": "end",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        },
        {
          "signature": "substr(name: KeyT, start: int, end: int = -1)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "start",
              "type": "int",
              "description": ""
            },
            {
              "name": "end",
              "type": "int = -1",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String substr(final String key, final int start, final int end)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "start",
              "type": "int",
              "description": ""
            },
            {
              "name": "end",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "The substring @deprecated Use Jedis#getrange(String, long, long) instead. Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 2.0.0."
          }
        },
        {
          "signature": "String getrange(final String key, final long startOffset, final long endOffset)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "startOffset",
              "type": "long",
              "description": ""
            },
            {
              "name": "endOffset",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V getrange(K key, long start, long end)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "end",
              "type": "long",
              "description": "the end type: long."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> getrange(K key, long start, long end)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "end",
              "type": "long",
              "description": "the end type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> getrange(K key, long start, long end)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "start",
              "type": "long",
              "description": "the start type: long."
            },
            {
              "name": "end",
              "type": "long",
              "description": "the end type: long."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "GetRange(ctx context.Context, key string, start, end int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "start",
              "type": "Any",
              "description": ""
            },
            {
              "name": "end",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "GETRANGE(key: RedisArgument, start: number, end: number)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "start",
              "type": "number",
              "description": ""
            },
            {
              "name": "end",
              "type": "number",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "getrange()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "substr()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "getrange(key: K, from: isize, to: isize)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "from",
              "type": "isize",
              "description": ""
            },
            {
              "name": "to",
              "type": "isize",
              "description": ""
            }
          ],
          "returns": {
            "type": "(String)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "getrange(key: K, from: isize, to: isize)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "from",
              "type": "isize",
              "description": ""
            },
            {
              "name": "to",
              "type": "isize",
              "description": ""
            }
          ],
          "returns": {
            "type": "(String)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "GetRange(double value, Exclude exclude, bool isStart)",
          "params": [
            {
              "name": "value",
              "type": "double",
              "description": ""
            },
            {
              "name": "exclude",
              "type": "Exclude",
              "description": ""
            },
            {
              "name": "isStart",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": ""
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "GetRange(double value, Exclude exclude, bool isStart)",
          "params": [
            {
              "name": "value",
              "type": "double",
              "description": ""
            },
            {
              "name": "exclude",
              "type": "Exclude",
              "description": ""
            },
            {
              "name": "isStart",
              "type": "bool",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "getrange(string $key, $start, $end)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$start",
              "type": "Any",
              "description": ""
            },
            {
              "name": "$end",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "string",
            "description": ""
          }
        }
      ]
    }
  },
  "HDEL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hdel(name: str, *keys: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "*keys",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hdel(final byte[] key, final byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields that were removed from the hash, not including specified but non-existing fields. If key does not exist, it is treated as an empty hash and this command returns 0."
          }
        },
        {
          "signature": "long hdel(final String key, final String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields that were removed from the hash, not including specified but non-existing fields. If key does not exist, it is treated as an empty hash and this command returns 0."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long hdel(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the number of fields that were removed from the hash, not including specified but non existing fields."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> hdel(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the number of fields that were removed from the hash, not including specified but non existing fields."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> hdel(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the number of fields that were removed from the hash, not including specified but non existing fields."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HDel(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HDEL(key: RedisArgument, field: RedisVariadicArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "field",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hdel()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hdel()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hdel(key: K, field: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hdel(key: K, field: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of fields that were removed."
          }
        },
        {
          "signature": "HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to delete."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields that were removed."
          }
        },
        {
          "signature": "HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of fields that were removed."
          }
        },
        {
          "signature": "HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to delete."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields that were removed."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of fields that were removed."
          }
        },
        {
          "signature": "HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to delete."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields that were removed."
          }
        },
        {
          "signature": "HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "The number of fields that were removed."
          }
        },
        {
          "signature": "HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to delete."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields that were removed."
          }
        }
      ],
      "php": [
        {
          "signature": "hdel(string $key, array $fields)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HEXISTS": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hexists(name: str, key: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[bool], bool]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "boolean hexists(final byte[] key, final byte[] field)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "field",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "boolean",
            "description": "true if the hash stored at key contains the specified field, false if the key is not found or the field is not present."
          }
        },
        {
          "signature": "boolean hexists(final String key, final String field)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "boolean",
            "description": "true if the hash stored at key contains the specified field, false if the key is not found or the field is not present."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean hexists(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: true if the hash contains field. false if the hash does not contain field, or key does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> hexists(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: true if the hash contains field. false if the hash does not contain field, or key does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> hexists(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: true if the hash contains field. false if the hash does not contain field, or key does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HExists(ctx context.Context, key, field string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "field",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*BoolCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HEXISTS(key: RedisArgument, field: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "field",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hexists()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hexists(key: K, field: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hexists(key: K, field: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashExists(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the hash contains field, <see langword=\"false\"/> if the hash does not contain field, or key does not exist."
          }
        },
        {
          "signature": "HashExists(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the hash contains field, <see langword=\"false\"/> if the hash does not contain field, or key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashExists(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the hash contains field, <see langword=\"false\"/> if the hash does not contain field, or key does not exist."
          }
        },
        {
          "signature": "HashExists(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to check."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if the hash contains field, <see langword=\"false\"/> if the hash does not contain field, or key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hexists(string $key, string $field)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HEXPIRE": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hexpire(, name: KeyT,, seconds: ExpiryT,, *fields: str,, nx: bool = False,, xx: bool = False,, gt: bool = False,, lt: bool = False,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "ExpiryT",
              "description": ""
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "gt",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "lt",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> hexpire(byte[] key, long seconds, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hexpire(byte[] key, long seconds, ExpiryOption condition, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "condition",
              "type": "ExpiryOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hexpire(String key, long seconds, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hexpire(String key, long seconds, ExpiryOption condition, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "condition",
              "type": "ExpiryOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> hexpire(K key, long seconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the TTL Duration"
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hexpire(K key, long seconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the TTL Duration"
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the ExpireArgs."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hexpire(K key, Duration seconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the TTL Duration"
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hexpire(K key, Duration seconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the TTL Duration"
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the ExpireArgs."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> hexpire(K key, long seconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the TTL Duration"
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hexpire(K key, long seconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the TTL Duration"
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the ExpireArgs."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hexpire(K key, Duration seconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the TTL Duration"
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hexpire(K key, Duration seconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the TTL Duration"
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the ExpireArgs."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> hexpire(K key, long seconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the TTL Duration"
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hexpire(K key, long seconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "long",
              "description": "the TTL Duration"
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the ExpireArgs."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hexpire(K key, Duration seconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the TTL Duration"
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hexpire(K key, Duration seconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "seconds",
              "type": "Duration",
              "description": "the TTL Duration"
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the ExpireArgs."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HExpire(ctx context.Context, key string, expiration time.Duration, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "expiration",
              "type": "time.Duration",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HEXPIRE()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hexpire(...args: [key: RedisKey, seconds: number | string, fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[], callback: Callback<number[]>])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        },
        {
          "signature": "hexpire(...args: [key: RedisKey, seconds: number | string, fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[]])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        },
        {
          "signature": "hexpire(...args: [key: RedisKey, seconds: number | string, nx: 'NX', fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[], callback: Callback<number[]>])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        },
        {
          "signature": "hexpire(...args: [key: RedisKey, seconds: number | string, nx: 'NX', fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[]])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        },
        {
          "signature": "hexpire(...args: [key: RedisKey, seconds: number | string, xx: 'XX', fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[], callback: Callback<number[]>])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hexpire(key: K, seconds: i64, opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        },
        {
          "signature": "hexpire_at(key: K, ts: i64, opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "ts",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hexpire(key: K, seconds: i64, opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "seconds",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        },
        {
          "signature": "hexpire_at(key: K, ts: i64, opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "ts",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "php": [
        {
          "signature": "hexpire(string $key, int $seconds, array $fields, string $flag = null)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$seconds",
              "type": "int",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            },
            {
              "name": "string $flag = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HEXPIREAT": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hexpireat(, name: KeyT,, unix_time_seconds: AbsExpiryT,, *fields: str,, nx: bool = False,, xx: bool = False,, gt: bool = False,, lt: bool = False,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "unix_time_seconds",
              "type": "AbsExpiryT",
              "description": ""
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "gt",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "lt",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> hexpireAt(byte[] key, long unixTimeSeconds, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "unixTimeSeconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hexpireAt(byte[] key, long unixTimeSeconds, ExpiryOption condition, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "unixTimeSeconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "condition",
              "type": "ExpiryOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hexpireAt(String key, long unixTimeSeconds, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "unixTimeSeconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hexpireAt(String key, long unixTimeSeconds, ExpiryOption condition, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "unixTimeSeconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "condition",
              "type": "ExpiryOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> hexpireat(K key, long timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hexpireat(K key, long timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hexpireat(K key, Date timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hexpireat(K key, Date timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hexpireat(K key, Instant timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Instant",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> hexpireat(K key, long timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hexpireat(K key, long timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hexpireat(K key, Date timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hexpireat(K key, Date timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hexpireat(K key, Instant timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Instant",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> hexpireat(K key, long timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hexpireat(K key, long timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hexpireat(K key, Date timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hexpireat(K key, Date timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hexpireat(K key, Instant timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Instant",
              "description": "the timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HExpireAt(ctx context.Context, key string, tm time.Time, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "tm",
              "type": "time.Time",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HEXPIREAT()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hexpire_at(key: K, ts: i64, opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "ts",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hexpire_at(key: K, ts: i64, opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "ts",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "php": [
        {
          "signature": "hexpireat(string $key, int $unixTimeSeconds, array $fields, string $flag = null)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$unixTimeSeconds",
              "type": "int",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            },
            {
              "name": "string $flag = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HEXPIRETIME": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hexpiretime(key: KeyT, *fields: str)",
          "params": [
            {
              "name": "key",
              "type": "KeyT",
              "description": "The hash key."
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": "Returns a list which contains for each field in the request: - `-2` if the field does not exist, or if the key does not exist. - `-1` if the field exists but has no associated expire time. - A positive integer representing the expiration Unix timestamp in seconds, if the field has an associated expiration time."
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> hexpireTime(byte[] key, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hexpireTime(String key, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> hexpiretime(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: expiration time as a UNIX timestamp in seconds; -1 indicating the field has no expiry time set; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> hexpiretime(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: expiration time as a UNIX timestamp in seconds; -1 indicating the field has no expiry time set; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> hexpiretime(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: expiration time as a UNIX timestamp in seconds; -1 indicating the field has no expiry time set; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HExpireTime(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HEXPIRETIME()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hexpire_time(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hexpire_time(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldGetExpireDateTime(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Expiration time, as a Unix timestamp in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldGetExpireDateTime(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Expiration time, as a Unix timestamp in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldGetExpireDateTime(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Expiration time, as a Unix timestamp in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldGetExpireDateTime(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Expiration time, as a Unix timestamp in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "php": [
        {
          "signature": "hexpiretime(string $key, array $fields)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HGET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hget(name: str, key: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[Optional[str]], Optional[str]]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String hget(final String key, final String field)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "V hget(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "V",
            "description": "V bulk-string-reply the value associated with field, or null when field is not present in the hash or key does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<V> hget(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "RedisFuture<V>",
            "description": "V bulk-string-reply the value associated with field, or null when field is not present in the hash or key does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<V> hget(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Mono<V>",
            "description": "V bulk-string-reply the value associated with field, or null when field is not present in the hash or key does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HGet(ctx context.Context, key, field string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "field",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HGET(key: RedisArgument, field: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "field",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hget()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hget(key: K, field: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hget(key: K, field: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Option<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "php": [
        {
          "signature": "hget(string $key, string $field)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "string|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HGETALL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hgetall(name: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[dict], dict]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "Map<String, String> hgetAll(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "Map<String, String>",
            "description": "All the fields and values contained into a hash."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Map<K, V> hgetall(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Map<K, V>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "Long hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Map<K, V>> hgetall(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Map<K, V>>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "RedisFuture<Long> hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> hgetall(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hgetall."
          }
        },
        {
          "signature": "Mono<Long> hgetall(KeyValueStreamingChannel<K, V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hgetall."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HGetAll(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*MapStringStringCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HGETALL(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hgetall()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hgetall(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(std::collections::HashMap<String, String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hgetall(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(std::collections::HashMap<String, String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashGetAll(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash to get all entries from."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "HashEntry[]",
            "description": "List of fields and their values stored in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hgetall(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "HGETDEL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hgetdel(name: str, *keys: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "*keys",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> hgetdel(String key, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<KeyValue<K, V>> hgetdel(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve and delete."
            }
          ],
          "returns": {
            "type": "List<KeyValue<K, V>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "Long hgetdel(KeyValueStreamingChannel<K, V> channel, K key, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve and delete."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long the number of fields that were removed from the hash."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<KeyValue<K, V>>> hgetdel(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve and delete."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<KeyValue<K, V>>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "RedisFuture<Long> hgetdel(KeyValueStreamingChannel<K, V> channel, K key, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve and delete."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long the number of fields that were removed from the hash."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> hgetdel(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve and delete."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "Mono<Long> hgetdel(KeyValueStreamingChannel<K, V> channel, K key, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve and delete."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long the number of fields that were removed from the hash."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HGetDel(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hget_del(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<Option<String>>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hget_del(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<Option<String>>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldGetAndDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashFieldGetAndDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashFieldGetAndDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashFieldGetAndDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldGetAndDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashFieldGetAndDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashFieldGetAndDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashFieldGetAndDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "php": [
        {
          "signature": "hgetdel(string $key, array $fields)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "HGETEX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hgetex(, name: KeyT,, *keys: str,, ex: Optional[ExpiryT] = None,, px: Optional[ExpiryT] = None,, exat: Optional[AbsExpiryT] = None,, pxat: Optional[AbsExpiryT] = None,, persist: bool = False,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "*keys",
              "type": "str",
              "description": ""
            },
            {
              "name": "ex",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "px",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "exat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "pxat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "persist",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> hgetex(String key, HGetExParams params, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "params",
              "type": "HGetExParams",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "Bulk reply"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<KeyValue<K, V>> hgetex(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "List<KeyValue<K, V>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "List<KeyValue<K, V>> hgetex(K key, HGetExArgs hGetExArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "hGetExArgs",
              "type": "HGetExArgs",
              "description": "hgetex arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "List<KeyValue<K, V>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "Long hgetex(KeyValueStreamingChannel<K, V> channel, K key, HGetExArgs hGetExArgs, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "hGetExArgs",
              "type": "HGetExArgs",
              "description": "hgetex arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long the number of fields that were removed from the hash."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<KeyValue<K, V>>> hgetex(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<KeyValue<K, V>>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "RedisFuture<List<KeyValue<K, V>>> hgetex(K key, HGetExArgs hGetExArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "hGetExArgs",
              "type": "HGetExArgs",
              "description": "hgetex arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<KeyValue<K, V>>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "RedisFuture<Long> hgetex(KeyValueStreamingChannel<K, V> channel, K key, HGetExArgs hGetExArgs, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "hGetExArgs",
              "type": "HGetExArgs",
              "description": "hgetex arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long the number of fields that were removed from the hash."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> hgetex(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "Flux<KeyValue<K, V>> hgetex(K key, HGetExArgs hGetExArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "hGetExArgs",
              "type": "HGetExArgs",
              "description": "hgetex arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long the number of fields that were removed from the hash."
          }
        },
        {
          "signature": "Mono<Long> hgetex(KeyValueStreamingChannel<K, V> channel, K key, HGetExArgs hGetExArgs, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "hGetExArgs",
              "type": "HGetExArgs",
              "description": "hgetex arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "fields to retrieve."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long the number of fields that were removed from the hash."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HGetEX(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hget_ex(key: K, fields: F, expire_at: Expiry)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            },
            {
              "name": "expire_at",
              "type": "Expiry",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hget_ex(key: K, fields: F, expire_at: Expiry)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            },
            {
              "name": "expire_at",
              "type": "Expiry",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue hashField, TimeSpan? expiry = null, bool persist = false, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "persist",
              "type": "bool",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the specified hash fields."
          }
        },
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue hashField, DateTime expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the specified hash fields."
          }
        },
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue[] hashFields, TimeSpan? expiry = null, bool persist = false, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get and set the expiration for."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "persist",
              "type": "bool",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the specified hash fields."
          }
        },
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue[] hashFields, DateTime expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get and set the expiration for."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the specified hash fields."
          }
        },
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue hashField, TimeSpan? expiry = null, bool persist = false, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "persist",
              "type": "bool",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the specified hash fields."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue hashField, TimeSpan? expiry = null, bool persist = false, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "persist",
              "type": "bool",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the specified hash fields."
          }
        },
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue hashField, DateTime expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the specified hash fields."
          }
        },
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue[] hashFields, TimeSpan? expiry = null, bool persist = false, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get and set the expiration for."
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "persist",
              "type": "bool",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the specified hash fields."
          }
        },
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue[] hashFields, DateTime expiry, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get and set the expiration for."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "The values of the specified hash fields."
          }
        },
        {
          "signature": "HashFieldGetAndSetExpiry(RedisKey key, RedisValue hashField, TimeSpan? expiry = null, bool persist = false, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "expiry",
              "type": "TimeSpan?",
              "description": "The exact date and time to set the expiration to."
            },
            {
              "name": "persist",
              "type": "bool",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "The values of the specified hash fields."
          }
        }
      ],
      "php": [
        {
          "signature": "hgetex(string $key, array $fields, string $modifier = HGETEX::NULL, int|bool $modifierValue = false)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            },
            {
              "name": "string $modifier = HGETEX::NULL",
              "type": "Any",
              "description": ""
            },
            {
              "name": "int|bool $modifierValue = false",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HINCRBY": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hincrby(name: str, key: str, amount: int = 1)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "str",
              "description": ""
            },
            {
              "name": "amount",
              "type": "int = 1",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hincrBy(final byte[] key, final byte[] field, final long value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "field",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        },
        {
          "signature": "long hincrBy(final String key, final String field, final long value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value of key after the increment"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long hincrby(K key, K field, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the value at field after the increment operation."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> hincrby(K key, K field, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the value at field after the increment operation."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> hincrby(K key, K field, long amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "amount",
              "type": "long",
              "description": "the increment type: long."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the value at field after the increment operation."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HIncrBy(ctx context.Context, key, field string, incr int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "field",
              "type": "string",
              "description": ""
            },
            {
              "name": "incr",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HINCRBY()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hincrby()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hincr(key: K, field: F, delta: D)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "delta",
              "type": "D",
              "description": ""
            }
          ],
          "returns": {
            "type": "(f64)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hincr(key: K, field: F, delta: D)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "delta",
              "type": "D",
              "description": ""
            }
          ],
          "returns": {
            "type": "(f64)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashDecrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to decrement."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the decrement operation."
          }
        },
        {
          "signature": "HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to decrement."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value at field after the decrement operation."
          }
        },
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashDecrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to decrement."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the decrement operation."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashDecrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to decrement."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the decrement operation."
          }
        },
        {
          "signature": "HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to decrement."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to decrement by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value at field after the decrement operation."
          }
        },
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashDecrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to decrement."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to decrement by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the decrement operation."
          }
        }
      ],
      "php": [
        {
          "signature": "hincrby(string $key, string $field, int $increment)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            },
            {
              "name": "$increment",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HINCRBYFLOAT": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hincrbyfloat(name: str, key: str, amount: float = 1.0)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "str",
              "description": ""
            },
            {
              "name": "amount",
              "type": "float = 1.0",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[float], float]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "double hincrByFloat(final byte[] key, final byte[] field, final double value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "field",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "double",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The new value at field after the increment operation"
          }
        },
        {
          "signature": "double hincrByFloat(final String key, final String field, final double value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "double",
              "description": ""
            }
          ],
          "returns": {
            "type": "double",
            "description": "The new value at field after the increment operation"
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Double hincrbyfloat(K key, K field, double amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "amount",
              "type": "double",
              "description": "the increment type: double."
            }
          ],
          "returns": {
            "type": "Double",
            "description": "Double bulk-string-reply the value of field after the increment."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Double> hincrbyfloat(K key, K field, double amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "amount",
              "type": "double",
              "description": "the increment type: double."
            }
          ],
          "returns": {
            "type": "RedisFuture<Double>",
            "description": "Double bulk-string-reply the value of field after the increment."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Double> hincrbyfloat(K key, K field, double amount)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "amount",
              "type": "double",
              "description": "the increment type: double."
            }
          ],
          "returns": {
            "type": "Mono<Double>",
            "description": "Double bulk-string-reply the value of field after the increment."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HIncrByFloat(ctx context.Context, key, field string, incr float64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "field",
              "type": "string",
              "description": ""
            },
            {
              "name": "incr",
              "type": "float64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*FloatCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HINCRBYFLOAT()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hincrbyfloat()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(key, hashField, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "Any",
              "description": "The field in the hash to increment."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(key, hashField, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "Any",
              "description": "The field in the hash to increment."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the increment operation."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "double",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "double",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(key, hashField, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "Any",
              "description": "The field in the hash to increment."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(key, hashField, -value, flags)",
          "params": [
            {
              "name": "key",
              "type": "Any",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "Any",
              "description": "The field in the hash to increment."
            },
            {
              "name": "-value",
              "type": "Any",
              "description": ""
            },
            {
              "name": "flags",
              "type": "Any",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "return",
            "description": "The value at field after the increment operation."
          }
        },
        {
          "signature": "HashIncrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field in the hash to increment."
            },
            {
              "name": "value",
              "type": "long",
              "description": "The amount to increment by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The value at field after the increment operation."
          }
        }
      ],
      "php": [
        {
          "signature": "hincrbyfloat(string $key, string $field, int|float $increment)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            },
            {
              "name": "$increment",
              "type": "int|float",
              "description": ""
            }
          ],
          "returns": {
            "type": "string",
            "description": ""
          }
        }
      ]
    }
  },
  "HKEYS": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hkeys(name: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[List], List]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "Set<String> hkeys(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "Set<String>",
            "description": "All the fields names contained into a hash."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<K> hkeys(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "List<K>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "Long hkeys(KeyStreamingChannel<K> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyStreamingChannel<K>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<K>> hkeys(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<K>>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "RedisFuture<Long> hkeys(KeyStreamingChannel<K> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyStreamingChannel<K>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<K> hkeys(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Flux<K>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hkeys."
          }
        },
        {
          "signature": "Mono<Long> hkeys(KeyStreamingChannel<K> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "KeyStreamingChannel<K>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hkeys."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HKeys(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HKEYS(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hkeys()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hkeys(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hkeys(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashKeys(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of fields in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashKeys(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of fields in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashKeys(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of fields in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashKeys(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of fields in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hkeys(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "HLEN": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hlen(name: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hlen(final byte[] key)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of entries (fields) contained in the hash stored at key. If the specified key does not exist, 0 is returned assuming an empty hash."
          }
        },
        {
          "signature": "long hlen(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of entries (fields) contained in the hash stored at key. If the specified key does not exist, 0 is returned assuming an empty hash."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long hlen(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply number of fields in the hash, or 0 when key does not exist."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> hlen(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply number of fields in the hash, or 0 when key does not exist."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> hlen(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply number of fields in the hash, or 0 when key does not exist."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HLen(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HLEN(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hlen(key: RedisKey, callback?: Callback<number>)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": ""
            },
            {
              "name": "callback?",
              "type": "Callback<number>",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number, Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hlen(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hlen(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashLength(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields in the hash, or 0 when key does not exist."
          }
        },
        {
          "signature": "HashLength(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields in the hash, or 0 when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashLength(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields in the hash, or 0 when key does not exist."
          }
        },
        {
          "signature": "HashLength(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The number of fields in the hash, or 0 when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hlen(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HMGET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hmget(name: str, keys: List, *args: List)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "keys",
              "type": "List",
              "description": ""
            },
            {
              "name": "*args",
              "type": "List",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[List], List]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> hmget(final String key, final String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "A list of all the values associated with the specified fields, in the same order of the request."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<KeyValue<K, V>> hmget(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the fields."
            }
          ],
          "returns": {
            "type": "List<KeyValue<K, V>>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "Long hmget(KeyValueStreamingChannel<K, V> channel, K key, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the fields."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<KeyValue<K, V>>> hmget(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the fields."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<KeyValue<K, V>>>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "RedisFuture<Long> hmget(KeyValueStreamingChannel<K, V> channel, K key, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the fields."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<KeyValue<K, V>> hmget(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the fields."
            }
          ],
          "returns": {
            "type": "Flux<KeyValue<K, V>>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hmget."
          }
        },
        {
          "signature": "Mono<Long> hmget(KeyValueStreamingChannel<K, V> channel, K key, K... fields)",
          "params": [
            {
              "name": "channel",
              "type": "KeyValueStreamingChannel<K, V>",
              "description": "the channel."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "the fields."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hmget."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HMGet(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*SliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HMGET(key: RedisArgument, fields: RedisVariadicArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "fields",
              "type": "RedisVariadicArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hmget()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hmget()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hmget(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hmget(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        },
        {
          "signature": "HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values associated with the given fields, in the same order as they are requested."
          }
        }
      ],
      "php": [
        {
          "signature": "hmget(string $key, array $fields)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "HMSET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hmset(name: str, mapping: dict)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "mapping",
              "type": "dict",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[str], str]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String hmset(final byte[] key, final Map<byte[], byte[]> hash)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "hash",
              "type": "Map<byte[], byte[]>",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Return OK or Exception if hash is empty @deprecated Use Jedis#hset(String, Map) instead. Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 4.0.0."
          }
        },
        {
          "signature": "String hmset(final String key, final Map<String, String> hash)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "hash",
              "type": "Map<String, String>",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "Return OK or Exception if hash is empty @deprecated Use Jedis#hset(String, Map) instead. Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 4.0.0."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "String hmset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the hash to apply."
            }
          ],
          "returns": {
            "type": "String",
            "description": "String simple-string-reply."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<String> hmset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the hash to apply."
            }
          ],
          "returns": {
            "type": "RedisFuture<String>",
            "description": "String simple-string-reply."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<String> hmset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the hash to apply."
            }
          ],
          "returns": {
            "type": "Mono<String>",
            "description": "String simple-string-reply."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HMSet(ctx context.Context, key string, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*BoolCmd",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hmset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hmset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hmset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hmset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hset_multiple(key: K, items: &'a [(F, V)])",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "items",
              "type": "&'a [(F, V)]",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hset_multiple(key: K, items: &'a [(F, V)])",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "items",
              "type": "&'a [(F, V)]",
              "description": ""
            }
          ],
          "returns": {
            "type": "(())",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        }
      ],
      "php": [
        {
          "signature": "hmset(string $key, array $dictionary)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$dictionary",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "mixed",
            "description": ""
          }
        }
      ]
    }
  },
  "HPERSIST": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hpersist(name: KeyT, *fields: str)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": "The name of the hash key."
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": "Returns a list which contains for each field in the request: - `-2` if the field does not exist, or if the key does not exist. - `-1` if the field exists but has no associated expiration time. - `1` if the expiration time was successfully removed from the field."
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> hpersist(byte[] key, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpersist(String key, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> hpersist(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to remove the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 1 indicating expiration time is removed; -1 field has no expiration time to be removed; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> hpersist(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to remove the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 1 indicating expiration time is removed; -1 field has no expiration time to be removed; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> hpersist(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to remove the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 1 indicating expiration time is removed; -1 field has no expiration time to be removed; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HPersist(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HPERSIST()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hpersist(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hpersist(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldPersist(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to remove expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "PersistResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>1</term> <description>Expiration time was removed.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldPersist(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to remove expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "PersistResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>1</term> <description>Expiration time was removed.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldPersist(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to remove expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "PersistResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>1</term> <description>Expiration time was removed.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldPersist(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to remove expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "PersistResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>1</term> <description>Expiration time was removed.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "php": [
        {
          "signature": "hpersist(string $key, array $fields)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HPEXPIRE": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hpexpire(, name: KeyT,, milliseconds: ExpiryT,, *fields: str,, nx: bool = False,, xx: bool = False,, gt: bool = False,, lt: bool = False,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "ExpiryT",
              "description": ""
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "gt",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "lt",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> hpexpire(byte[] key, long milliseconds, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpexpire(byte[] key, long milliseconds, ExpiryOption condition, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "condition",
              "type": "ExpiryOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpexpire(String key, long milliseconds, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpexpire(String key, long milliseconds, ExpiryOption condition, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": ""
            },
            {
              "name": "condition",
              "type": "ExpiryOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> hpexpire(K key, long milliseconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hpexpire(K key, long milliseconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hpexpire(K key, Duration milliseconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "Duration",
              "description": "the milliseconds."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hpexpire(K key, Duration milliseconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "Duration",
              "description": "the milliseconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> hpexpire(K key, long milliseconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hpexpire(K key, long milliseconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hpexpire(K key, Duration milliseconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "Duration",
              "description": "the milliseconds."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hpexpire(K key, Duration milliseconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "Duration",
              "description": "the milliseconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> hpexpire(K key, long milliseconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hpexpire(K key, long milliseconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "long",
              "description": "the milliseconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hpexpire(K key, Duration milliseconds, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "Duration",
              "description": "the milliseconds."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hpexpire(K key, Duration milliseconds, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "milliseconds",
              "type": "Duration",
              "description": "the milliseconds."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is 0; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "expiration",
              "type": "time.Duration",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HPEXPIRE()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hpexpire(...args: [key: RedisKey, milliseconds: number | string, fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[], callback: Callback<number[]>])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        },
        {
          "signature": "hpexpire(...args: [key: RedisKey, milliseconds: number | string, fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[]])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        },
        {
          "signature": "hpexpire(...args: [key: RedisKey, milliseconds: number | string, nx: 'NX', fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[], callback: Callback<number[]>])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        },
        {
          "signature": "hpexpire(...args: [key: RedisKey, milliseconds: number | string, nx: 'NX', fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[]])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        },
        {
          "signature": "hpexpire(...args: [key: RedisKey, milliseconds: number | string, xx: 'XX', fieldsToken: 'FIELDS', numfields: number | string, ...fields: (string | Buffer)[], callback: Callback<number[]>])",
          "params": [
            {
              "name": "...args",
              "type": "[key",
              "description": ""
            }
          ],
          "returns": {
            "type": "Result<number[], Context>",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hpexpire(key: K, milliseconds: i64, opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        },
        {
          "signature": "hpexpire_at(key: K, ts: i64,  opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "ts",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hpexpire(key: K, milliseconds: i64, opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "milliseconds",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        },
        {
          "signature": "hpexpire_at(key: K, ts: i64,  opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "ts",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "TimeSpan",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to set expire time."
            },
            {
              "name": "expiry",
              "type": "DateTime",
              "description": "The exact date to expiry to set."
            },
            {
              "name": "when",
              "type": "ExpireWhen",
              "description": "under which condition the expiration will be set using ExpireWhen."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "ExpireResult[]",
            "description": "Empty array if the key does not exist. Otherwise, returns an array where each item is the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>2</term> <description>Field deleted because the specified expiration time is due.</description> </item> <item> <term>1</term> <description>Expiration time set/updated.</description> </item> <item> <term>0</term> <description>Expiration time is not set/update (a specified ExpireWhen condition is not met).</description> </item> <item> <term>-1</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "php": [
        {
          "signature": "hpexpire(string $key, int $milliseconds, array $fields, string $flag = null)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$milliseconds",
              "type": "int",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            },
            {
              "name": "string $flag = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HPEXPIREAT": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hpexpireat(, name: KeyT,, unix_time_milliseconds: AbsExpiryT,, *fields: str,, nx: bool = False,, xx: bool = False,, gt: bool = False,, lt: bool = False,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "unix_time_milliseconds",
              "type": "AbsExpiryT",
              "description": ""
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            },
            {
              "name": "nx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "xx",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "gt",
              "type": "bool = False",
              "description": ""
            },
            {
              "name": "lt",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> hpexpireAt(byte[] key, long unixTimeMillis, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "unixTimeMillis",
              "type": "long",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpexpireAt(byte[] key, long unixTimeMillis, ExpiryOption condition, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "unixTimeMillis",
              "type": "long",
              "description": ""
            },
            {
              "name": "condition",
              "type": "ExpiryOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpexpireAt(String key, long unixTimeMillis, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "unixTimeMillis",
              "type": "long",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpexpireAt(String key, long unixTimeMillis, ExpiryOption condition, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "unixTimeMillis",
              "type": "long",
              "description": ""
            },
            {
              "name": "condition",
              "type": "ExpiryOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> hpexpireat(K key, long timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hpexpireat(K key, long timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hpexpireat(K key, Date timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hpexpireat(K key, Date timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "List<Long> hpexpireat(K key, Instant timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Instant",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> hpexpireat(K key, long timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hpexpireat(K key, long timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hpexpireat(K key, Date timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hpexpireat(K key, Date timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<List<Long>> hpexpireat(K key, Instant timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Instant",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> hpexpireat(K key, long timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hpexpireat(K key, long timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "long",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hpexpireat(K key, Date timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hpexpireat(K key, Date timestamp, ExpireArgs expireArgs, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Date",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "expireArgs",
              "type": "ExpireArgs",
              "description": "the expiry arguments."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        },
        {
          "signature": "Flux<Long> hpexpireat(K key, Instant timestamp, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "timestamp",
              "type": "Instant",
              "description": "the milliseconds-timestamp type: posix time."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to set the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: 2 indicating the specific field is deleted already due to expiration, or provided expiry interval is in the past; 1 indicating expiration time is set/updated; 0 indicating the expiration time is not set (a provided NX | XX | GT | LT condition is not met); -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "tm",
              "type": "time.Time",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HPEXPIREAT()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hpexpire_at(key: K, ts: i64,  opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "ts",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hpexpire_at(key: K, ts: i64,  opt: ExpireOption, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "ts",
              "type": "i64",
              "description": ""
            },
            {
              "name": "opt",
              "type": "ExpireOption",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "hpexpireat(string $key, int $unixTimeMilliseconds, array $fields, string $flag = null)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$unixTimeMilliseconds",
              "type": "int",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            },
            {
              "name": "string $flag = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HPEXPIRETIME": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hpexpiretime(key: KeyT, *fields: str)",
          "params": [
            {
              "name": "key",
              "type": "KeyT",
              "description": "The hash key."
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": "Returns a list which contains for each field in the request: - `-2` if the field does not exist, or if the key does not exist. - `-1` if the field exists but has no associated expire time. - A positive integer representing the expiration Unix timestamp in milliseconds, if the field has an associated expiration time."
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> hpexpireTime(byte[] key, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpexpireTime(String key, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> hpexpiretime(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: expiration time as a UNIX timestamp in milliseconds; -1 indicating the field has no expiry time set; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> hpexpiretime(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: expiration time as a UNIX timestamp in milliseconds; -1 indicating the field has no expiry time set; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> hpexpiretime(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: expiration time as a UNIX timestamp in milliseconds; -1 indicating the field has no expiry time set; -2 indicating there is no such field @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HPExpireTime(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HPEXPIRETIME()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hpexpire_time(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hpexpire_time(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "hpexpiretime(string $key, array $fields)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HPTTL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hpttl(key: KeyT, *fields: str)",
          "params": [
            {
              "name": "key",
              "type": "KeyT",
              "description": "The hash key."
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": "Returns a list which contains for each field in the request: - `-2` if the field does not exist, or if the key does not exist. - `-1` if the field exists but has no associated expire time. - A positive integer representing the TTL in milliseconds if the field has an associated expiration time."
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> hpttl(byte[] key, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> hpttl(String key, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> hpttl(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: the time to live in milliseconds; or a negative value in order to signal an error. The command returns -1 if the key exists but has no associated expiration time. The command returns -2 if the key does not exist. @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> hpttl(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: the time to live in milliseconds; or a negative value in order to signal an error. The command returns -1 if the key exists but has no associated expiration time. The command returns -2 if the key does not exist. @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> hpttl(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: the time to live in milliseconds; or a negative value in order to signal an error. The command returns -1 if the key exists but has no associated expiration time. The command returns -2 if the key does not exist. @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HPTTL(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HPTTL()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hpttl(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hpttl(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Time to live, in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Time to live, in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Time to live, in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Time to live, in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "php": [
        {
          "signature": "hpttl(string $key, array $fields)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HRANDFIELD": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hrandfield(key: str, count: Optional[int] = None, withvalues: bool = False)",
          "params": [
            {
              "name": "key",
              "type": "str",
              "description": ""
            },
            {
              "name": "count",
              "type": "Optional[int] = None",
              "description": ""
            },
            {
              "name": "withvalues",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "String hrandfield(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "String",
            "description": "multiple random fields from a hash."
          }
        },
        {
          "signature": "List<String> hrandfield(final String key, final long count)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "count",
              "type": "long",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "multiple random fields from a hash."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "K hrandfield(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "K",
            "description": "array-reply list of field names. @since 6.1"
          }
        },
        {
          "signature": "List<K> hrandfield(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "fields."
            }
          ],
          "returns": {
            "type": "List<K>",
            "description": "array-reply list of field names. @since 6.1"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<K> hrandfield(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<K>",
            "description": "array-reply list of field names. @since 6.1"
          }
        },
        {
          "signature": "RedisFuture<List<K>> hrandfield(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "fields."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<K>>",
            "description": "array-reply list of field names. @since 6.1"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<K> hrandfield(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<K>",
            "description": "array-reply list of field names. @since 6.1"
          }
        },
        {
          "signature": "Flux<K> hrandfield(K key, long count)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "count",
              "type": "long",
              "description": "fields."
            }
          ],
          "returns": {
            "type": "Flux<K>",
            "description": "array-reply list of field names. @since 6.1"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HRandField(ctx context.Context, key string, count int)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "count",
              "type": "int",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HRANDFIELD(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hrandfield()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hrandfield()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hrandfield()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashRandomField(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A random hash field name or RedisValue.Null if the hash does not exist."
          }
        },
        {
          "signature": "HashRandomField(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A random hash field name or RedisValue.Null if the hash does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashRandomField(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A random hash field name or RedisValue.Null if the hash does not exist."
          }
        },
        {
          "signature": "HashRandomField(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue",
            "description": "A random hash field name or RedisValue.Null if the hash does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hrandfield(string $key, int $count = 1, bool $withValues = false)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "int $count = 1",
              "type": "Any",
              "description": ""
            },
            {
              "name": "bool $withValues = false",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "HSCAN": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hscan(, name: KeyT,, cursor: int = 0,, match: Union[PatternT, None] = None,, count: Optional[int] = None,, no_values: Union[bool, None] = None,)",
          "params": [
            {
              "name": "name",
              "type": "KeyT",
              "description": ""
            },
            {
              "name": "cursor",
              "type": "int = 0",
              "description": ""
            },
            {
              "name": "match",
              "type": "Union[PatternT, None] = None",
              "description": ""
            },
            {
              "name": "count",
              "type": "Optional[int] = None",
              "description": ""
            },
            {
              "name": "no_values",
              "type": "Union[bool, None] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "ScanResult<String> hscanNoValues(final String key, final String cursor, final ScanParams params)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "cursor",
              "type": "String",
              "description": ""
            },
            {
              "name": "params",
              "type": "ScanParams",
              "description": ""
            }
          ],
          "returns": {
            "type": "ScanResult<String>",
            "description": "OK @deprecated Use Jedis#set(String, String, redis.clients.jedis.params.SetParams) with redis.clients.jedis.params.SetParams#px(long). Deprecated in Jedis 8.0.0. Mirrors Redis deprecation since 2.6.12."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "MapScanCursor<K, V> hscan(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "MapScanCursor<K, V>",
            "description": "StreamScanCursor scan cursor."
          }
        },
        {
          "signature": "KeyScanCursor<K> hscanNovalues(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "KeyScanCursor<K>",
            "description": "StreamScanCursor scan cursor. @since 6.4"
          }
        },
        {
          "signature": "MapScanCursor<K, V> hscan(K key, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "MapScanCursor<K, V>",
            "description": "StreamScanCursor scan cursor."
          }
        },
        {
          "signature": "KeyScanCursor<K> hscanNovalues(K key, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "KeyScanCursor<K>",
            "description": "StreamScanCursor scan cursor. @since 6.4"
          }
        },
        {
          "signature": "MapScanCursor<K, V> hscan(K key, ScanCursor scanCursor, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanCursor",
              "type": "ScanCursor",
              "description": "cursor to resume from a previous scan, must not be null."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "MapScanCursor<K, V>",
            "description": "StreamScanCursor scan cursor."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<MapScanCursor<K, V>> hscan(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<MapScanCursor<K, V>>",
            "description": "StreamScanCursor scan cursor."
          }
        },
        {
          "signature": "RedisFuture<KeyScanCursor<K>> hscanNovalues(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<KeyScanCursor<K>>",
            "description": "StreamScanCursor scan cursor. @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<MapScanCursor<K, V>> hscan(K key, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisFuture<MapScanCursor<K, V>>",
            "description": "StreamScanCursor scan cursor."
          }
        },
        {
          "signature": "RedisFuture<KeyScanCursor<K>> hscanNovalues(K key, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisFuture<KeyScanCursor<K>>",
            "description": "StreamScanCursor scan cursor. @since 6.4"
          }
        },
        {
          "signature": "RedisFuture<MapScanCursor<K, V>> hscan(K key, ScanCursor scanCursor, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanCursor",
              "type": "ScanCursor",
              "description": "cursor to resume from a previous scan, must not be null."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisFuture<MapScanCursor<K, V>>",
            "description": "StreamScanCursor scan cursor."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<MapScanCursor<K, V>> hscan(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<MapScanCursor<K, V>>",
            "description": "StreamScanCursor scan cursor. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hscan."
          }
        },
        {
          "signature": "Mono<KeyScanCursor<K>> hscanNovalues(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<KeyScanCursor<K>>",
            "description": "StreamScanCursor scan cursor. @deprecated since 6.4 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hscanNovalues."
          }
        },
        {
          "signature": "Mono<MapScanCursor<K, V>> hscan(K key, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "Mono<MapScanCursor<K, V>>",
            "description": "StreamScanCursor scan cursor. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hscan."
          }
        },
        {
          "signature": "Mono<KeyScanCursor<K>> hscanNovalues(K key, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "Mono<KeyScanCursor<K>>",
            "description": "StreamScanCursor scan cursor. @deprecated since 6.4 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hscanNovalues."
          }
        },
        {
          "signature": "Mono<MapScanCursor<K, V>> hscan(K key, ScanCursor scanCursor, ScanArgs scanArgs)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "scanCursor",
              "type": "ScanCursor",
              "description": "cursor to resume from a previous scan, must not be null."
            },
            {
              "name": "scanArgs",
              "type": "ScanArgs",
              "description": ""
            }
          ],
          "returns": {
            "type": "Mono<MapScanCursor<K, V>>",
            "description": "StreamScanCursor scan cursor. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hscan."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HScan(ctx context.Context, key string, cursor uint64, match string, count int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "cursor",
              "type": "uint64",
              "description": ""
            },
            {
              "name": "match",
              "type": "string",
              "description": ""
            },
            {
              "name": "count",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*ScanCmd",
            "description": ""
          }
        },
        {
          "signature": "HScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "cursor",
              "type": "uint64",
              "description": ""
            },
            {
              "name": "match",
              "type": "string",
              "description": ""
            },
            {
              "name": "count",
              "type": "int64",
              "description": ""
            }
          ],
          "returns": {
            "type": "*ScanCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HSCAN()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hscan()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hscan()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hscan()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hscan()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "pattern",
              "type": "RedisValue",
              "description": "The pattern of keys to get entries for."
            },
            {
              "name": "pageSize",
              "type": "int",
              "description": "The page size to iterate by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "IEnumerable<HashEntry>",
            "description": "Yields all elements of the hash matching the pattern."
          }
        },
        {
          "signature": "HashScan(RedisKey key, RedisValue pattern = default, int pageSize = RedisBase.CursorUtils.DefaultLibraryPageSize, long cursor = RedisBase.CursorUtils.Origin, int pageOffset = 0, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "pattern",
              "type": "RedisValue",
              "description": "The pattern of keys to get entries for."
            },
            {
              "name": "pageSize",
              "type": "int",
              "description": "The page size to iterate by."
            },
            {
              "name": "cursor",
              "type": "long",
              "description": "The cursor position to start at."
            },
            {
              "name": "pageOffset",
              "type": "int",
              "description": "The page offset to start at."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "IEnumerable<HashEntry>",
            "description": "Yields all elements of the hash matching the pattern."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "pattern",
              "type": "RedisValue",
              "description": "The pattern of keys to get entries for."
            },
            {
              "name": "pageSize",
              "type": "int",
              "description": "The page size to iterate by."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "IEnumerable<HashEntry>",
            "description": "Yields all elements of the hash matching the pattern."
          }
        },
        {
          "signature": "HashScan(RedisKey key, RedisValue pattern = default, int pageSize = RedisBase.CursorUtils.DefaultLibraryPageSize, long cursor = RedisBase.CursorUtils.Origin, int pageOffset = 0, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "pattern",
              "type": "RedisValue",
              "description": "The pattern of keys to get entries for."
            },
            {
              "name": "pageSize",
              "type": "int",
              "description": "The page size to iterate by."
            },
            {
              "name": "cursor",
              "type": "long",
              "description": "The cursor position to start at."
            },
            {
              "name": "pageOffset",
              "type": "int",
              "description": "The page offset to start at."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "IEnumerable<HashEntry>",
            "description": "Yields all elements of the hash matching the pattern."
          }
        }
      ],
      "php": [
        {
          "signature": "hscan(string $key, $cursor, ?array $options = null)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$cursor",
              "type": "Any",
              "description": ""
            },
            {
              "name": "?array $options = null",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  },
  "HSET": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hset(, name: str,, key: Optional[str] = None,, value: Optional[str] = None,, mapping: Optional[dict] = None,, items: Optional[list] = None,)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "value",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "mapping",
              "type": "Optional[dict] = None",
              "description": ""
            },
            {
              "name": "items",
              "type": "Optional[list] = None",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hset(final byte[] key, final byte[] field, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "field",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final byte[] key, final Map<byte[], byte[]> hash)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "hash",
              "type": "Map<byte[], byte[]>",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final String key, final String field, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hset(final String key, final Map<String, String> hash)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "hash",
              "type": "Map<String, String>",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean hset(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "field",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "Long hset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> hset(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "field",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "RedisFuture<Long> hset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> hset(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "field",
              "type": "K",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        },
        {
          "signature": "Mono<Long> hset(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply: the number of fields that were added. @since 5.3"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HSet(ctx context.Context, key string, values ...interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "values",
              "type": "...interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HSET(...[key, value, fieldValue]: SingleFieldArguments | MultipleFieldsArguments)",
          "params": [
            {
              "name": "...[key, value, fieldValue]",
              "type": "SingleFieldArguments | MultipleFieldsArguments",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        },
        {
          "signature": "hset()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hset(key: K, field: F, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hset(key: K, field: F, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(usize)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field to set in the hash."
            },
            {
              "name": "value",
              "type": "RedisValue",
              "description": "The value to set."
            },
            {
              "name": "when",
              "type": "When",
              "description": "Which conditions under which to set the field value (defaults to always)."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        },
        {
          "signature": "HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "HashEntry[]",
              "description": ""
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "void",
            "description": "<see langword=\"true\"/> if field is a new field in the hash and value was set, <see langword=\"false\"/> if field already exists in the hash and the value was updated."
          }
        }
      ],
      "php": [
        {
          "signature": "hset(string $key, string $field, string $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            },
            {
              "name": "$value",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HSETEX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hsetex(, name: str,, key: Optional[str] = None,, value: Optional[str] = None,, mapping: Optional[dict] = None,, items: Optional[list] = None,, ex: Optional[ExpiryT] = None,, px: Optional[ExpiryT] = None,, exat: Optional[AbsExpiryT] = None,, pxat: Optional[AbsExpiryT] = None,, data_persist_option: Optional[HashDataPersistOptions] = None,, keepttl: bool = False,)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "value",
              "type": "Optional[str] = None",
              "description": ""
            },
            {
              "name": "mapping",
              "type": "Optional[dict] = None",
              "description": ""
            },
            {
              "name": "items",
              "type": "Optional[list] = None",
              "description": ""
            },
            {
              "name": "ex",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "px",
              "type": "Optional[ExpiryT] = None",
              "description": ""
            },
            {
              "name": "exat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "pxat",
              "type": "Optional[AbsExpiryT] = None",
              "description": ""
            },
            {
              "name": "data_persist_option",
              "type": "Optional[HashDataPersistOptions] = None",
              "description": ""
            },
            {
              "name": "keepttl",
              "type": "bool = False",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hsetex(byte[] key, HSetExParams params, byte[] field, byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "params",
              "type": "HSetExParams",
              "description": ""
            },
            {
              "name": "field",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hsetex(byte[] key, HSetExParams params, Map<byte[], byte[]> hash)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "params",
              "type": "HSetExParams",
              "description": ""
            },
            {
              "name": "hash",
              "type": "Map<byte[], byte[]>",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hsetex(String key, HSetExParams params, String field, String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "params",
              "type": "HSetExParams",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hsetex(String key, HSetExParams params, Map<String, String> hash)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "params",
              "type": "HSetExParams",
              "description": ""
            },
            {
              "name": "hash",
              "type": "Map<String, String>",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, and the HSET just produced an update of the value, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long hsetex(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long long-reply: 0 if no fields were set, 1 if all the fields were set @since 6.6"
          }
        },
        {
          "signature": "Long hsetex(K key, HSetExArgs hSetExArgs, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "hSetExArgs",
              "type": "HSetExArgs",
              "description": "hsetex arguments."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long long-reply: 0 if no fields were set, 1 if all the fields were set @since 6.6"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> hsetex(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long long-reply: 0 if no fields were set, 1 if all the fields were set @since 6.6"
          }
        },
        {
          "signature": "RedisFuture<Long> hsetex(K key, HSetExArgs hSetExArgs, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "hSetExArgs",
              "type": "HSetExArgs",
              "description": "hsetex arguments."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long long-reply: 0 if no fields were set, 1 if all the fields were set @since 6.6"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> hsetex(K key, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long long-reply: 0 if no fields were set, 1 if all the fields were set @since 6.6"
          }
        },
        {
          "signature": "Mono<Long> hsetex(K key, HSetExArgs hSetExArgs, Map<K, V> map)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key of the hash."
            },
            {
              "name": "hSetExArgs",
              "type": "HSetExArgs",
              "description": "hsetex arguments."
            },
            {
              "name": "map",
              "type": "Map<K, V>",
              "description": "the field/value pairs to update."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long long-reply: 0 if no fields were set, 1 if all the fields were set @since 6.6"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HSetEX(ctx context.Context, key string, fieldsAndValues ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fieldsAndValues",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hset_ex(key: K, hash_field_expiration_options: &'a HashFieldExpirationOptions, fields_values: &'a [(F, V)])",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "hash_field_expiration_options",
              "type": "&'a HashFieldExpirationOptions",
              "description": ""
            },
            {
              "name": "fields_values",
              "type": "&'a [(F, V)]",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hset_ex(key: K, hash_field_expiration_options: &'a HashFieldExpirationOptions, fields_values: &'a [(F, V)])",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "hash_field_expiration_options",
              "type": "&'a HashFieldExpirationOptions",
              "description": ""
            },
            {
              "name": "fields_values",
              "type": "&'a [(F, V)]",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "hsetex(string $key, array $fieldValueMap, string $setModifier = HSETEX::SET_NULL, string $ttlModifier = HSETEX::TTL_NULL, int|bool $ttlModifierValue = false)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fieldValueMap",
              "type": "array",
              "description": ""
            },
            {
              "name": "string $setModifier = HSETEX::SET_NULL",
              "type": "Any",
              "description": ""
            },
            {
              "name": "string $ttlModifier = HSETEX::TTL_NULL",
              "type": "Any",
              "description": ""
            },
            {
              "name": "int|bool $ttlModifierValue = false",
              "type": "Any",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HSETNX": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hsetnx(name: str, key: str, value: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "str",
              "description": ""
            },
            {
              "name": "value",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[bool], bool]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hsetnx(final byte[] key, final byte[] field, final byte[] value)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "field",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "value",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        },
        {
          "signature": "long hsetnx(final String key, final String field, final String value)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            },
            {
              "name": "value",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": "If the field already exists, 0 is returned, otherwise if a new field is created 1 is returned."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Boolean hsetnx(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "Boolean integer-reply specifically: 1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and no operation was performed."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Boolean> hsetnx(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "RedisFuture<Boolean>",
            "description": "Boolean integer-reply specifically: 1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and no operation was performed."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Boolean> hsetnx(K key, K field, V value)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            },
            {
              "name": "value",
              "type": "V",
              "description": "the value."
            }
          ],
          "returns": {
            "type": "Mono<Boolean>",
            "description": "Boolean integer-reply specifically: 1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and no operation was performed."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HSetNX(ctx context.Context, key, field string, value interface{})",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "field",
              "type": "string",
              "description": ""
            },
            {
              "name": "value",
              "type": "interface{}",
              "description": ""
            }
          ],
          "returns": {
            "type": "*BoolCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HSETNX()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hsetnx()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hset_nx(key: K, field: F, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hset_nx(key: K, field: F, value: V)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "field",
              "type": "F",
              "description": ""
            },
            {
              "name": "value",
              "type": "V",
              "description": ""
            }
          ],
          "returns": {
            "type": "(bool)",
            "description": ""
          }
        }
      ],
      "php": [
        {
          "signature": "hsetnx(string $key, string $field, string $value)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            },
            {
              "name": "$value",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HSTRLEN": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hstrlen(name: str, key: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            },
            {
              "name": "key",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[int], int]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "long hstrlen(final byte[] key, final byte[] field)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "field",
              "type": "byte[]",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": ""
          }
        },
        {
          "signature": "long hstrlen(final String key, final String field)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "field",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "long",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "Long hstrlen(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long integer-reply the string length of the field value, or 0 when field is not present in the hash or key does not exist at all."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<Long> hstrlen(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long integer-reply the string length of the field value, or 0 when field is not present in the hash or key does not exist at all."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Mono<Long> hstrlen(K key, K field)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "field",
              "type": "K",
              "description": "the field type: key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long integer-reply the string length of the field value, or 0 when field is not present in the hash or key does not exist at all."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HStrLen(ctx context.Context, key, field string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "Any",
              "description": ""
            },
            {
              "name": "field",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HSTRLEN(key: RedisArgument, field: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            },
            {
              "name": "field",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hstrlen()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field containing the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at field, or 0 when key does not exist."
          }
        },
        {
          "signature": "HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field containing the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at field, or 0 when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field containing the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at field, or 0 when key does not exist."
          }
        },
        {
          "signature": "HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashField",
              "type": "RedisValue",
              "description": "The field containing the string."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long",
            "description": "The length of the string at field, or 0 when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hstrlen(string $key, string $field)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$field",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "int",
            "description": ""
          }
        }
      ]
    }
  },
  "HTTL": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "httl(key: KeyT, *fields: str)",
          "params": [
            {
              "name": "key",
              "type": "KeyT",
              "description": "The hash key."
            },
            {
              "name": "*fields",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "ResponseT",
            "description": "Returns a list which contains for each field in the request: - `-2` if the field does not exist, or if the key does not exist. - `-1` if the field exists but has no associated expire time. - A positive integer representing the TTL in seconds if the field has an associated expiration time."
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<Long> httl(byte[] key, byte[]... fields)",
          "params": [
            {
              "name": "key",
              "type": "byte[]",
              "description": ""
            },
            {
              "name": "fields",
              "type": "byte[]...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        },
        {
          "signature": "List<Long> httl(String key, String... fields)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            },
            {
              "name": "fields",
              "type": "String...",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": ""
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<Long> httl(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "List<Long>",
            "description": "a list of Long values for each of the fields provided: the time to live in seconds; or a negative value in order to signal an error. The command returns -1 if the key exists but has no associated expiration time. The command returns -2 if the key does not exist. @since 6.4"
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<Long>> httl(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<Long>>",
            "description": "a list of Long values for each of the fields provided: the time to live in seconds; or a negative value in order to signal an error. The command returns -1 if the key exists but has no associated expiration time. The command returns -2 if the key does not exist. @since 6.4"
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<Long> httl(K key, K... fields)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            },
            {
              "name": "fields",
              "type": "K...",
              "description": "one or more fields to get the TTL for."
            }
          ],
          "returns": {
            "type": "Flux<Long>",
            "description": "a list of Long values for each of the fields provided: the time to live in seconds; or a negative value in order to signal an error. The command returns -1 if the key exists but has no associated expiration time. The command returns -2 if the key does not exist. @since 6.4"
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HTTL(ctx context.Context, key string, fields ...string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            },
            {
              "name": "fields",
              "type": "...string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*IntSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HTTL()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "httl(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "httl(key: K, fields: F)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            },
            {
              "name": "fields",
              "type": "F",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<IntegerReplyOrNoOp>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Time to live, in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Time to live, in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Time to live, in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        },
        {
          "signature": "HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "hashFields",
              "type": "RedisValue[]",
              "description": "The fields in the hash to get expire time."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "long[]",
            "description": "Empty array if the key does not exist. Otherwise, returns the result of operation for given fields: <list type=\"table\"> <listheader> <term>Result</term> <description>Description</description> </listheader> <item> <term>&gt; 0</term> <description>Time to live, in milliseconds.</description> </item> <item> <term>-1</term> <description>Field has no associated expiration time.</description> </item> <item> <term>-2</term> <description>No such field exists.</description> </item> </list>"
          }
        }
      ],
      "php": [
        {
          "signature": "httl(string $key, array $fields)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            },
            {
              "name": "$fields",
              "type": "array",
              "description": ""
            }
          ],
          "returns": {
            "type": "array|null",
            "description": ""
          }
        }
      ]
    }
  },
  "HVALS": {
    "api_calls": {
      "redis_py": [
        {
          "signature": "hvals(name: str)",
          "params": [
            {
              "name": "name",
              "type": "str",
              "description": ""
            }
          ],
          "returns": {
            "type": "Union[Awaitable[List], List]",
            "description": ""
          }
        }
      ],
      "jedis": [
        {
          "signature": "List<String> hvals(final String key)",
          "params": [
            {
              "name": "key",
              "type": "String",
              "description": ""
            }
          ],
          "returns": {
            "type": "List<String>",
            "description": "All the fields values contained into a hash."
          }
        }
      ],
      "lettuce_sync": [
        {
          "signature": "List<V> hvals(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "List<V>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "Long hvals(ValueStreamingChannel<V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "streaming channel that receives a call for every value."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Long",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_async": [
        {
          "signature": "RedisFuture<List<V>> hvals(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<List<V>>",
            "description": "Long count of the keys."
          }
        },
        {
          "signature": "RedisFuture<Long> hvals(ValueStreamingChannel<V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "streaming channel that receives a call for every value."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "RedisFuture<Long>",
            "description": "Long count of the keys."
          }
        }
      ],
      "lettuce_reactive": [
        {
          "signature": "Flux<V> hvals(K key)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Flux<V>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hvals."
          }
        },
        {
          "signature": "Mono<Long> hvals(ValueStreamingChannel<V> channel, K key)",
          "params": [
            {
              "name": "channel",
              "type": "ValueStreamingChannel<V>",
              "description": "streaming channel that receives a call for every value."
            },
            {
              "name": "key",
              "type": "K",
              "description": "the key."
            }
          ],
          "returns": {
            "type": "Mono<Long>",
            "description": "Long count of the keys. @deprecated since 6.0 in favor of consuming large results through the org.reactivestreams.Publisher returned by #hvals."
          }
        }
      ],
      "go-redis": [
        {
          "signature": "HVals(ctx context.Context, key string)",
          "params": [
            {
              "name": "ctx",
              "type": "context.Context",
              "description": ""
            },
            {
              "name": "key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "*StringSliceCmd",
            "description": ""
          }
        }
      ],
      "node_redis": [
        {
          "signature": "HVALS(key: RedisArgument)",
          "params": [
            {
              "name": "key",
              "type": "RedisArgument",
              "description": ""
            }
          ],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "ioredis": [
        {
          "signature": "hvals()",
          "params": [],
          "returns": {
            "type": "Any",
            "description": ""
          }
        }
      ],
      "redis_rs_sync": [
        {
          "signature": "hvals(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "redis_rs_async": [
        {
          "signature": "hvals(key: K)",
          "params": [
            {
              "name": "key",
              "type": "K",
              "description": ""
            }
          ],
          "returns": {
            "type": "(Vec<String>)",
            "description": ""
          }
        }
      ],
      "nredisstack_sync": [
        {
          "signature": "HashValues(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashValues(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "nredisstack_async": [
        {
          "signature": "HashValues(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values in the hash, or an empty list when key does not exist."
          }
        },
        {
          "signature": "HashValues(RedisKey key, CommandFlags flags = CommandFlags.None)",
          "params": [
            {
              "name": "key",
              "type": "RedisKey",
              "description": "The key of the hash."
            },
            {
              "name": "flags",
              "type": "CommandFlags",
              "description": "The flags to use for this operation."
            }
          ],
          "returns": {
            "type": "RedisValue[]",
            "description": "List of values in the hash, or an empty list when key does not exist."
          }
        }
      ],
      "php": [
        {
          "signature": "hvals(string $key)",
          "params": [
            {
              "name": "$key",
              "type": "string",
              "description": ""
            }
          ],
          "returns": {
            "type": "array",
            "description": ""
          }
        }
      ]
    }
  }
}